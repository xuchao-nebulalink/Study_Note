# Keil新建STM32工程

> 前置条件：已经安装好 **Keil MDK-ARM**、**DFP设备包**、**ST-LINK驱动**

## 零、安装DFP设备包（重要前置步骤）

### 什么是DFP包？

**DFP（Device Family Pack）** = 设备包，包含了特定芯片系列的所有底层文件：
- 启动文件（startup）
- 系统初始化文件（system）
- 寄存器定义头文件
- Flash下载算法
- 调试配置文件
- 示例代码

==没装DFP包，Keil就找不到你的芯片型号，也无法编译下载！==

---

### 安装步骤

#### 第一步：打开Pack Installer

---

#### 第二步：选择芯片厂商

左侧 **Devices** 栏目：
1. 展开 `Generic`
2. 找到 `STMicroelectronics`
3. 点击展开
---
#### 第三步：选择芯片系列

中间 **Device** 列表：
- 找到你的芯片系列，比如：
  - `STM32F1 Series` - F103/F101/F102等
  - `STM32F4 Series` - F401/F407/F411等
  - `STM32H7 Series` - H743/H750等
- 点击选中
---
#### 第四步：安装必要的包

右侧 **Packs** 栏目会显示该系列的所有可用包：

**必装的包（打勾✅表示已安装，叉号❌表示未安装）：**

1. ==**Keil::STM32F1xx_DFP**==（对于F103芯片）
   - 这是设备包，**必须装！**
   - ==这个包已经包含了：启动文件、寄存器定义、HAL库、LL库、示例代码==
   - 点击右边的 `Install` 或 `Update` 按钮
   - 版本号一般选最新稳定版（比如2.3.x）

2. **ARM::CMSIS** 或 **ARM::CMSIS-CORE**
   - Cortex-M内核的标准接口
   - ==一般Keil安装时就有了，不用手动装==
   - 如果没有，在右侧包列表里找到并安装

**不需要单独安装的：**
- ❌ ~~HAL库~~ - 已经包含在DFP里了
- ❌ ~~LL库~~ - 已经包含在DFP里了
- ❌ ~~启动文件~~ - 已经包含在DFP里了

> **重点**：对于STM32，==只装DFP包就够了！== 其他都在里面。

![[Pasted image 20251023002709.png]]

---

#### 第五步：等待下载安装

- 点击 `Install` 后，Keil会自动下载
- 右下角显示进度条
- 安装完成后，状态变成 ✅ Up to date

**如果下载很慢或失败：**
- 检查网络（需要访问国外服务器）
- 或者去ST官网手动下载DFP包后离线安装
---

## 一、新建工程的完整流程

### 第一步：创建工程

**1. 打开Keil MDK**
- 启动 uVision 5

**2. 新建项目**
- 点击菜单 `Project` → `New µVision Project...`
- 选择一个空文件夹（建议每个项目单独一个文件夹）
- 输入工程名，比如 `LED_Test`
- 点击"保存"

![[Pasted image 20251023000623.png]]

> **提示**：工程名不要用中文，避免后续编译出问题

---

### 第二步：选择目标芯片

**1. 在弹出的窗口中选择你的MCU型号**

比如要用 STM32F103C8T6：
- 展开 `STMicroelectronics`
- 展开 `STM32F1 Series`
- 展开 `STM32F103`
- 选择 `STM32F103C8`（注意C8对应C8T6）

**2. 点击 OK**
![[Pasted image 20251023000722.png]]

> **小技巧**：可以在搜索框直接输入型号快速定位

---

### 第三步：管理运行时环境（MRTE）

这一步很关键！决定了工程用什么库。

**弹出 "Manage Run-Time Environment" 窗口后：**

#### ==方式1：最小配置（裸寄存器开发）==

只勾选最基础的两项：
- ✅ `CMSIS` → `CORE`（ARM内核必须）
- ✅ `Device` → `Startup`（启动文件必须）

点击 OK，这样工程就是纯寄存器开发模式。

![[Pasted image 20251023000828.png]]

#### ==方式2：HAL库配置（直接用CubeMX）==

**对于STM32F1系列，Keil的MRTE里一般只有SPL，没有HAL库选项。**

==要用HAL库，直接用STM32CubeMX生成工程：==

1. 下载安装 **STM32CubeMX**（ST官网免费）
2. 新建项目 → 选择你的芯片型号
3. 配置时钟、引脚、外设（图形化）
4. `Project Manager` → `Toolchain/IDE` 选 **MDK-ARM**
5. `GENERATE CODE`
6. 用Keil打开生成的工程
7. ==HAL库自动配好，直接用！==

> **提示**：新手建议先用裸寄存器理解底层，熟练后再用CubeMX+HAL

---

### 第四步：查看自动生成的文件

配置完MRTE后，Keil会自动生成一些必备文件。

==如果只勾选了CMSIS + Startup（最小配置），会生成4个文件：==

**1. 在工程目录下（和.uvprojx同级）：**
```
项目文件夹/
├─ RTE_Device.h                  （运行时环境配置头文件）
├─ startup_stm32f10x_md.s        （启动文件，汇编语言）
└─ system_stm32f10x.c            （系统初始化文件）
```

**2. 在RTE子文件夹下：**
```
项目文件夹/RTE/
└─ _Target_1/
   └─ RTE_Components.h          （组件配置头文件）
```

![[Pasted image 20251023003512.png]]

**这4个文件的作用：**

| 文件名                      | 作用                          | 需要改吗       |
| ------------------------ | --------------------------- | ---------- |
| `startup_stm32f10x_md.s` | 芯片上电后第一个执行的代码，设置中断向量表、初始化堆栈 | ❌ 不用改      |
| `system_stm32f10x.c`     | 系统初始化，配置时钟等                 | ⚠️ 可以改时钟配置 |
| `RTE_Device.h`           | 运行时环境配置                     | ❌ 不用改      |
| `RTE_Components.h`       | 记录勾选了哪些组件                   | ❌ 自动生成，不用改 |

> **注意**：这些文件是DFP包自动生成的，==不要删除！== 它们是程序运行的基础。

---

### 第五步：新建main.c文件

现在工程还没有main函数，需要自己建：

**1. 右键点击 `Source Group 1`**
- 选择 `Add New Item to Group 'Source Group 1'...`

**2. 选择 `C File (.c)`**
- 文件名输入：`main`
- 点击 `Add`

**3. 写最简单的代码测试：**

```c
#include "stm32f10x.h"  // 根据你的芯片型号，头文件名会不同

int main(void)
{
    // 什么都不做，先测试能不能编译通过
    while(1)
    {
        
    }
}
```

![[Pasted image 20251023003831.png]]

---

### 第六步：配置工程选项（很重要！）

**1. 点击工具栏的"魔术棒"图标（Options for Target）**

或者菜单 `Project` → `Options for Target 'Target 1'...`

#### ==A. Target 选项卡==

**必须配置的：**
- `Xtal (MHz)`: 外部晶振频率，通常是 **8.0** MHz
- `IROM1`: Flash起始地址和大小
  - Start: `0x08000000`（STM32的Flash起始地址）
  - Size: `0x10000`（对于64KB的芯片，F103C8是64KB）
- `IRAM1`: RAM起始地址和大小
  - Start: `0x20000000`
  - Size: `0x5000`（对于20KB的RAM，F103C8是20KB）

![[Pasted image 20251023004056.png]]

> **怎么知道Flash和RAM大小？**
> - 看芯片型号：F103**C8**T6 → C8表示64KB Flash
> - 或者查Datasheet

#### ==B. Output 选项卡==

- ✅ 勾选 `Create HEX File`（生成hex文件，用于烧录）
- `Name of Executable`: 可以改输出文件名
- `Select Folder for Objects`: 编译生成的中间文件路径

![[Pasted image 20251023004154.png]]

#### ==C. Listing 选项卡==

- 可以不改，这是生成汇编列表文件的配置

#### ==D. C/C++ 选项卡==

**重要配置：**
- `Optimization`: 优化级别
  - 调试时选 `-O0`（不优化）
  - 发布时可选 `-O2` 或 `-O3`
- `Define`: 定义宏
  - ==必须添加芯片型号宏==，比如 `STM32F103xB`
  - 如果用HAL库，会自动添加 `USE_HAL_DRIVER`
- `Include Paths`: 添加头文件路径
  - 如果用到自己的头文件目录，要在这里添加

**常见的宏定义：**
```
STM32F103xB           // F103C8/CB
USE_HAL_DRIVER        // 使用HAL库
HSE_VALUE=8000000     // 外部晶振8MHz
```

![[Pasted image 20251023004411.png]]

#### ==E. Debug 选项卡==

**选择调试器：**
- 右侧 `Use:` 下拉选择 `ST-Link Debugger`
- 点击右边的 `Settings` 按钮

**ST-Link设置：**
- `Port:` 选择 `SW`（SWD接口，两线调试）
- 点击 `Flash Download` 选项卡
  - ✅ 勾选 `Reset and Run`（下载后自动运行）
- 可以点击 `Utilities` 选项卡看烧录设置

![[Pasted image 20251023004700.png]]

> **测试连接**：点击 `Settings` 后，如果能看到芯片ID和Flash大小，说明ST-Link连接正常

---

### 第七步：编译工程

**1. 点击编译按钮**
- 工具栏的🔨图标（Build）
- 或快捷键 `F7`
![[Pasted image 20251023004753.png]]
**2. 查看编译结果**
- 下方 `Build Output` 窗口
- 看到 `0 Error(s), 0 Warning(s)` 说明编译成功✅

![[Pasted image 20251023004804.png]]

**如果有错误：**
- 检查头文件路径是否正确
- 检查宏定义是否添加
- 检查芯片型号是否选对

---

### 第八步：下载程序到芯片

**1. 连接ST-Link和开发板**
- 接好 `SWDIO`、`SWCLK`、`GND`、`3.3V`（或VCC）

**2. 点击下载按钮**
- 工具栏的 `Download` 按钮（闪电图标）
- 或快捷键 `F8`

**3. 看到下载进度条和成功提示**

![[Pasted image 20251023004854.png]]

---

## 二、工程文件详解

### 1. 自动生成的4个文件

#### ==startup_stm32f10x_md.s（启动文件）==

**位置**：工程根目录  
**语言**：汇编语言  
**作用**：芯片上电后第一个执行的代码

**主要内容：**
1. **中断向量表** - 所有中断的入口地址
2. **堆栈初始化** - 设置堆栈指针
3. **跳转到SystemInit** - 调用系统初始化
4. **跳转到main** - 最后进入main函数

**需要改吗？** ❌ 一般不用改

> **注意**：不同容量芯片的启动文件不同：
> - `startup_stm32f10x_md.s` - 中等容量（64KB/128KB Flash）
> - `startup_stm32f10x_ld.s` - 小容量（16KB/32KB Flash）
> - `startup_stm32f10x_hd.s` - 大容量（256KB/512KB Flash）

---

#### ==system_stm32f10x.c（系统初始化）==

**位置**：工程根目录  
**语言**：C语言  
**作用**：系统时钟和基本配置

**主要函数：**
```c
void SystemInit(void)              // 系统初始化（启动时自动调用）
void SystemCoreClockUpdate(void)   // 更新时钟变量
```

**什么时候调用？**  
启动文件会在进入main之前自动调用 `SystemInit()`

**可以改吗？** ⚠️ 可以改时钟配置（不建议新手改）

---

#### ==RTE_Device.h（运行时环境配置）==

**位置**：工程根目录  
**作用**：MRTE的配置头文件

**需要改吗？** ❌ 不用改，自动生成的

---

#### ==RTE_Components.h（组件配置）==

**位置**：`RTE/_Target_1/` 文件夹下  
**作用**：记录你勾选了哪些组件

**内容示例：**
```c
#define RTE_DEVICE_STARTUP_STM32F10X_MD    // 勾选了Startup
#define RTE_CMSIS_CORE                     // 勾选了CMSIS
```

**需要改吗？** ❌ 自动生成，不用改

---

### 2. DFP包里的头文件（不会生成到工程，但可以用）

虽然工程里看不到，但你可以在代码里用这些头文件：

#### ==stm32f10x.h（寄存器定义）==

**作用**：定义所有寄存器的地址和结构体

**示例：**
```c
#include "stm32f10x.h"  // 包含这个头文件

// 使用寄存器
RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;  // 开启GPIOC时钟
GPIOC->CRH = xxx;                    // 配置PC13
```

#### ==core_cm3.h（ARM内核定义）==

**作用**：CMSIS标准的Cortex-M3内核定义

**内容：**
- NVIC中断控制
- SysTick系统滴答定时器
- 内核寄存器定义

**示例：**
```c
NVIC_EnableIRQ(EXTI0_IRQn);  // 使能外部中断0
__disable_irq();             // 关闭总中断
```

> **这些头文件在哪？**  
> 在Keil的Pack文件夹里，编译时会自动找到，不用担心。

---

### 3. 你自己创建的文件

这部分是你的代码：
- ==`main.c`== - 主函数（必须有）
- 其他功能模块的 `.c` 和 `.h` 文件

---

### 4. 编译生成的文件（在Output文件夹）

编译后会在 `Objects` 或 `Listings` 文件夹下生成：

- `.o` - 目标文件（每个.c文件对应一个）
- `.axf` - 可执行文件（带调试信息）
- ==`.hex`== - 十六进制烧录文件（重要！用于下载）
- `.bin` - 二进制文件（可选）
- `.map` - 内存映射文件（查看代码占用空间）
- `.lst` - 汇编列表文件

> **重要**：下载程序到芯片时，用的就是 `.hex` 文件

---

### 5. 如果用CubeMX生成HAL工程，还会有：

如果你用STM32CubeMX生成的工程，会多很多HAL库文件：

**HAL库头文件：**
- `stm32f1xx_hal.h` - HAL库主头文件
- `stm32f1xx_hal_conf.h` - HAL配置文件
- `stm32f1xx_hal_gpio.h` - GPIO驱动头文件
- `stm32f1xx_hal_uart.h` - 串口驱动头文件
- 等等...

**HAL库源文件：**
- `stm32f1xx_hal_gpio.c` - GPIO驱动
- `stm32f1xx_hal_uart.c` - 串口驱动
- `stm32f1xx_hal_tim.c` - 定时器驱动
- 等等...

> **注意**：HAL库文件很多，但都是CubeMX自动生成的，不用自己管

---

## 三、STM32的四种开发方式

### 方式对比一览表

| 方式       | 上手速度 | 可读性/维护 | 代码体积  | 性能实时性 | 生态/示例 | 适用场景           |
| -------- | ---- | ------ | ----- | ----- | ----- | -------------- |
| 裸寄存器     | ★    | ★      | ★★★★★ | ★★★★★ | ★     | 极限优化、超小固件、底层学习 |
| SPL（老库）  | ★★   | ★★☆    | ★★★   | ★★★   | ★★    | 维护旧项目          |
| HAL      | ★★★★ | ★★★★   | ★★    | ★★★   | ★★★★★ | 新项目/中间件/快速落地   |
| LL       | ★★★  | ★★★    | ★★★★  | ★★★★  | ★★★★  | 对性能/时序敏感的模块    |
| HAL+LL混合 | ★★★★ | ★★★★   | ★★★   | ★★★★  | ★★★★★ | ==推荐的工程实践==    |

---

### A. 裸寄存器（Register）

#### 什么是裸寄存器？

直接操作芯片寄存器，用位运算控制硬件。

#### 怎么写代码？

```c
// 直接操作寄存器位
GPIOC->CRH = ...
RCC->APB2ENR |= ...
```

#### 依赖文件

- 只需要 **CMSIS 头文件**（随DFP包提供）
- 最轻量，不依赖任何库

#### MRTE勾选

- ✅ `CMSIS` → `CORE`（必选）
- ✅ `Device` → `Startup`（必选）
- ❌ **不要勾** HAL/LL/SPL

#### 宏定义

```c
STM32F103xB              // 芯片型号宏（DFP自动加）
HSE_VALUE=8000000        // 外部晶振频率（可选）
```

#### 最小示例代码（F1 PC13点灯）

```c
#include "stm32f10x.h"

int main(void)
{
    // 1. 使能GPIOC时钟
  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
    
    // 2. 配置PC13为推挽输出，2MHz速度
  GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
    GPIOC->CRH |= (0x2 << GPIO_CRH_MODE13_Pos);  // MODE=10(2MHz), CNF=00(推挽)
    
    while(1)
    {
        GPIOC->BSRR = (1U << 13);  // 置位PC13，LED灭
        for(volatile int i=0; i<500000; i++);  // 延时
        
        GPIOC->BRR = (1U << 13);   // 复位PC13，LED亮
        for(volatile int i=0; i<500000; i++);  // 延时
    }
}
```

#### 优点
- ✅ 代码体积最小
- ✅ 执行效率最高
- ✅ 完全掌控硬件细节
- ✅ 学习底层最快

#### 缺点
- ❌ 上手难度大，要熟悉寄存器手册
- ❌ 代码可读性差
- ❌ 可移植性差（不同芯片寄存器不同）
- ❌ 容易踩坑（忘开时钟、时序错误）

#### 常见的坑

**最容易忘的：开时钟！**
```c
// 错误示例：忘记开时钟，GPIO不工作
GPIOC->CRH = xxx;  // ❌ GPIOC时钟没开，寄存器写不进去

// 正确写法
RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;  // ✅ 先开时钟
GPIOC->CRH = xxx;  // ✅ 再配置
```

#### 适合场景
- 资源极小的芯片（比如Flash只有16KB）
- 竞赛要求极限优化
- 学习底层原理
- 对代码体积和性能有极致要求

---

### B. 标准外设库（SPL）- "老库"

#### 什么是SPL？

ST官方早期提供的外设库，F1/F4时代很流行。

#### 怎么写代码？

```c
GPIO_Init();
USART_Init();
TIM_Cmd();
```

#### 依赖

- 需要下载 **STM32Fxxx_StdPeriph_Lib** 包
- 现在基本停止更新了

#### 优点
- 比裸寄存器好读
- 早期教程和资料多

#### 缺点
- ==已停止更新==，新芯片没有SPL
- 与HAL生态不兼容
- 中间件支持弱
- 官方不推荐了

#### 适合场景
- **维护旧项目**（以前用SPL写的）
- 学习老教程
- ==新项目不建议用！==

> **重要提示**：现在学STM32直接跳过SPL，学HAL就行

---

### C. HAL库（官方主推，推荐）

#### 什么是HAL？

**Hardware Abstraction Layer**（硬件抽象层），ST官方主推的开发方式。

#### 特点

- 高度抽象，函数接口统一
- ==配合 STM32CubeMX 自动生成代码==
- 所有新芯片都支持
- 与中间件完美配合（USB、lwIP、FreeRTOS等）

#### 怎么用HAL库？

==直接用STM32CubeMX生成工程，不要在Keil里手动配置HAL库！==

**原因：**
- 很多芯片的DFP包不提供HAL库选项
- 手动配置HAL库太麻烦
- CubeMX是官方推荐方式

#### 宏定义
```c
USE_HAL_DRIVER    // 使用HAL库（勾选HAL时自动添加）
STM32F103xB       // 芯片型号
```

#### 最小示例代码（HAL版PC13点灯）

```c
#include "stm32f1xx_hal.h"

void SystemClock_Config(void);  // 时钟配置函数

int main(void)
{
    // 1. HAL库初始化
    HAL_Init();
    
    // 2. 配置系统时钟
    SystemClock_Config();
    
    // 3. 使能GPIOC时钟
    __HAL_RCC_GPIOC_CLK_ENABLE();
    
    // 4. 配置PC13为输出
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // 推挽输出
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    
    while(1)
    {
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);    // LED灭
        HAL_Delay(500);
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);  // LED亮
        HAL_Delay(500);
    }
}

// 系统时钟配置（简化版）
void SystemClock_Config(void)
{
    // 这里配置时钟树，一般用CubeMX自动生成
    // 手写比较复杂，建议用CubeMX
}
```

#### 优点
- ✅ 代码可读性好
- ✅ 所有新芯片都支持
- ✅ 配合CubeMX快速开发
- ✅ 中间件生态完善
- ✅ 官方持续维护

#### 缺点
- ❌ 代码体积大
- ❌ 执行效率比寄存器低
- ❌ 要学习HAL的"套路"

#### 适合场景
- ==90%的新项目首选==
- 快速开发原型
- 使用USB、网络、文件系统等中间件
- 团队协作项目

---

### D. LL库（Low Layer）

#### 什么是LL？

**Low Layer**，比HAL更贴近寄存器的库。

#### 特点

- 函数基本是寄存器位的封装
- 比HAL轻量，比寄存器好读
- 可以和HAL混用

#### 示例代码

```c
// LL库写法
LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_13);
LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_13);

// 对比寄存器写法
GPIOC->BSRR = GPIO_PIN_13;
GPIOC->BRR = GPIO_PIN_13;
```

#### 优点
- 比HAL轻量
- 比寄存器好读
- 执行效率接近寄存器

#### 缺点
- 没有HAL那么高层抽象
- 示例代码相对少一些

#### 适合场景
- 对性能敏感的模块
- 快速GPIO翻转
- 高频中断处理

---

### E. 混合用法（推荐的工程实践）

#### 策略

==大部分用HAL，关键路径用LL或寄存器==

#### 实际做法

**常规功能用HAL：**
- 时钟配置
- GPIO初始化
- UART、I2C、SPI配置
- USB、网络、文件系统

**性能关键部分用LL/寄存器：**
- 高频GPIO翻转
- 中断服务函数
- DMA配置微调
- 定时器捕获/比较

#### 示例

```c
// 初始化用HAL
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

// 运行时快速翻转用寄存器
GPIOC->BSRR = GPIO_PIN_13;  // 比HAL_GPIO_WritePin快
```

#### 注意事项

- ❌ 不要同时用SPL和HAL（会冲突）
- ✅ HAL和LL可以混用
- ✅ HAL下也能直接操作寄存器
- ⚠️ 注意不要破坏HAL已配置的状态

---

## 四、怎么选择开发方式？

### 新手入门

==推荐：HAL库 + CubeMX==

**理由：**
- 上手快，图形化配置
- 示例多，遇到问题好解决
- 不用记那么多寄存器

### 有经验的工程师

==推荐：HAL + LL混合==

**理由：**
- 开发效率高
- 性能也能保证
- 灵活度最大

### 资源受限的项目

==推荐：LL或寄存器==

**理由：**
- 代码体积小
- 性能好
- 但开发周期会长一些

### 学习底层原理

==推荐：先寄存器，再HAL==

**理由：**
- 先用寄存器理解底层
- 再用HAL提高效率
- 两者结合理解最深

---

## 五、常见问题

### Q1：编译错误：找不到头文件？

**原因：**
- 头文件路径没添加
- 或者DFP包没装

**解决：**
1. 检查 `Options` → `C/C++` → `Include Paths`
2. 确认Pack Installer里装了对应的DFP

### Q2：下载失败，连接不上ST-Link？

**检查：**
1. ST-Link驱动装了吗？
2. 线接对了吗（SWDIO、SWCLK、GND、VCC）
3. 开发板供电了吗？
4. Debug选项里选的是ST-Link吗？

### Q3：程序下载成功但不运行？

**可能原因：**
1. BOOT引脚设置错了（检查BOOT0要接GND）
2. 代码卡在某个地方了（加断点调试）
3. 时钟配置错误导致程序跑不起来

### Q4：用HAL库编译后代码太大，超过32KB？

**解决方法：**
1. 只勾选用到的HAL模块
2. 改用LL库或寄存器实现关键部分
3. 优化等级调到 `-O2` 或 `-O3`
4. 升级Keil版本（买MDK-Pro或用限制更大的Lite版）

### Q5：HAL_Delay()不工作？

**原因：**
- `SysTick` 没初始化
- `HAL_Init()` 没调用

**解决：**
```c
int main(void)
{
    HAL_Init();  // 必须先调用这个，初始化SysTick
    
    // 你的代码...
}
```

### Q6：CubeMX生成的工程和手建工程有什么区别？

**CubeMX生成的好处：**
- 自动配置时钟树
- 自动配置引脚复用
- 自动生成初始化代码
- 更不容易出错

**手建工程：**
- 更灵活
- 理解更深
- 但容易踩坑

==建议：先用CubeMX快速上手，熟练后再手建==

---

## 六、下一步学什么？

工程建好了，接下来可以学：

1. **GPIO控制** - LED、按键、继电器
2. **时钟系统** - 理解时钟树配置
3. **中断系统** - 外部中断、定时器中断
4. **串口通信** - UART调试、printf重定向
5. **定时器** - 延时、PWM、输入捕获
6. **ADC/DAC** - 模拟信号采集和输出

---

## 小结

**新建工程的核心步骤：**
1. ✅ 新建项目 → 选芯片
2. ✅ MRTE配置（CMSIS + Startup + HAL/LL）
3. ✅ 添加main.c
4. ✅ 配置工程选项（Target、Output、Debug）
5. ✅ 编译、下载、运行

**开发方式选择：**
- 新手/快速开发 → ==HAL==
- 性能优化 → ==LL或寄存器==
- 最佳实践 → ==HAL + LL混合==

**记住：**
- ==忘开时钟是最常见的错误==
- ==先让程序跑起来，再优化性能==
- ==多看官方示例代码，少走弯路==

---

