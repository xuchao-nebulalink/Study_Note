# 5镜运动控制通信协议

## 1. 基本信息

- **通信方式**：串口（UART）
- **波特率**：建议 2Mbaud 或 3Mbaud（根据光栅尺上传频率选择）
- **数据位**：8
- **停止位**：1
- **校验位**：无（使用CRC16帧校验）

---

## 2. 系统架构

### 2.1 系统拓扑
```
上位机 <--串口--> 下位机（主控） <--总线--> 6个控制器
```
- 上位机发送指令给下位机
- 下位机根据控制器ID将指令转发给对应控制器
- 控制器执行后通过下位机应答上位机

### 2.2 模块划分
- **L1模块**：6个电机（5直线+1旋转），3个光栅尺
- **L2模块**：5个电机（全直线），1个压电转盘
- **L5模块**：3个压电螺钉，3个光栅尺

### 2.3 控制器划分
| 控制器ID | 名称 | 控制对象 |
|---------|------|---------|
| C1 | 步进电机控制1 | L2前3个直线电机 |
| C2 | 步进电机控制2 | L2后2个直线电机 |
| C3 | 步进电机控制3 | L1前3个直线电机 |
| C4 | 步进电机控制4 | L1后2个直线电机+1个旋转电机 |
| C5 | 压电转盘控制器 | 1个压电转盘 |
| C6 | 压电螺钉控制器 | 3个压电螺钉 |

### 2.4 电机编号规则
- **L1电机**：M1-M6（M1-M5直线，M6旋转）
- **L2电机**：M7-M11（全直线）
- **L2压电转盘**：P1
- **L5压电螺钉**：S1-S3

### 2.5 控制器与设备映射表

| 控制器ID | 控制的设备编号    | 设备类型                 | 所属模块 |
| ----- | ---------- | -------------------- | ---- |
| C1    | M7, M8, M9 | 直线电机                 | L2   |
| C2    | M10, M11   | 直线电机                 | L2   |
| C3    | M1, M2, M3 | 直线电机                 | L1   |
| C4    | M4, M5, M6 | 直线电机(M4-M5)、旋转电机(M6) | L1   |
| C5    | P1         | 压电转盘                 | L2   |
| C6    | S1, S2, S3 | 压电螺钉                 | L5   |

**注意**：光栅尺(G1-G6)直接连接下位机，不经过控制器。

### 2.6 光栅尺编号
- **L1光栅尺**：G1-G3
- **L5光栅尺**：G4-G6

---

## 3. 帧格式总览

### 3.1 控制指令（上位机→下位机）
**字符串格式**，结构化分层设计。

```
$<主命令>,<字段1>,<字段2>,...,<字段N>;CCCC
```

- `$`：帧头
- `;`：帧尾
- `CCCC`：CRC16校验值（4位十六进制大写）

### 3.2 应答报文（下位机→上位机）
同样字符串格式。

### 3.3 光栅尺数据上传（下位机→上位机）
**二进制格式**，高频持续上传。

```
[0xAA][0x55][LEN][DATA...][CRC16_H][CRC16_L]
```

---

## 4. 控制指令详细设计

### 4.1 指令分类

控制指令按主命令分为三大类：
- **MOTOR**：电机相关操作
- **GRATING**：光栅尺相关操作
- **SYSTEM**：系统级操作

### 4.2 MOTOR 指令格式

```
$MOTOR,<控制器ID>,<目标>,<子命令>,<参数...>;CCCC
```

#### 字段说明
- **控制器ID**：C1-C6，或 ALL（广播所有控制器）
- **目标**：电机编号（M1-M11, P1, S1-S3），或 ALL（该控制器下所有设备）
- **子命令**：具体操作类型
- **参数**：根据子命令不同

#### 参数格式约定
**浮点数格式**：
- 支持正负号：`10.5`, `-5.3`
- 支持整数形式：`10`, `-5`（不强制小数点）
- 支持多位小数：`123.456789`
- **不支持**科学计数法（如 `1.5e-3` 不允许）
- 示例：`10.5`, `-20.0`, `0.001`, `100`

#### 子命令列表

| 子命令        | 适用对象     | 参数       | 说明            |
| ---------- | -------- | -------- | ------------- |
| STOP       | 所有电机     | 无        | 停止运动          |
| MOVE_REL   | 直线/旋转/转盘 | `<位移>`   | 相对运动，浮点数，支持正负 |
| MOVE_ABS   | 直线/旋转/转盘 | `<目标位置>` | 绝对运动，浮点数      |
| ROT_FWD    | 压电螺钉     | `<转数>`   | 正转，浮点数        |
| ROT_REV    | 压电螺钉     | `<转数>`   | 反转，浮点数        |
| HOME       | 所有电机     | 无        | 找零            |
| GET_STATUS | 所有电机     | 无        | 查询状态          |

#### 单个指令示例
```
$MOTOR,C1,M7,STOP;7793
$MOTOR,C3,M1,MOVE_REL,10.5;31DF
$MOTOR,C4,M6,MOVE_ABS,90.0;93DE
$MOTOR,C6,S1,ROT_FWD,5.0;5EA9
$MOTOR,C1,M7,HOME;3B25
$MOTOR,C1,ALL,STOP;2A99
```

#### 批量指令格式
同一主命令下，用 `|` 分隔多个操作，每个操作完整指定控制器ID和目标：
```
$MOTOR,<CID1>,<目标1>,<子命令1>,<参数1>|<CID2>,<目标2>,<子命令2>,<参数2>|...;CCCC
```

**批量示例**：
```
// 同一控制器多个电机
$MOTOR,C1,M7,MOVE_REL,10.0|C1,M8,MOVE_REL,15.5|C1,M9,STOP;7775

// 跨控制器多个电机（多轴协同）
$MOTOR,C1,M7,MOVE_REL,10.0|C2,M10,MOVE_REL,20.0|C3,M1,MOVE_ABS,50.0;FF3A

// 批量停止不同控制器
$MOTOR,C1,M7,STOP|C1,M8,STOP|C2,M9,STOP|C3,M1,STOP;2F3D

// 压电螺钉批量控制
$MOTOR,C6,S1,ROT_FWD,3.0|C6,S2,ROT_REV,2.5|C6,S3,STOP;EB4A
```

**注意**：
- 批量指令仅限同一主命令（MOTOR/GRATING/SYSTEM）
- 可以跨控制器操作，提高多轴协同效率
- 每个子命令必须完整指定控制器ID和目标
- 下位机对批量指令中的每个操作分别应答，不做批量回复
- 某个操作失败不影响其他操作的执行和应答

#### ALL指令说明
当目标指定为 `ALL` 时，表示该控制器下的所有设备：
```
$MOTOR,C1,ALL,STOP;2A99  // 停止C1控制器下所有电机（M7,M8,M9）
```

**ALL指令应答规则**：
- 下位机对每个设备分别应答
- 例如上述指令会收到3个应答：M7、M8、M9各一个

### 4.3 GRATING 指令格式

光栅尺直接连接下位机，不需要控制器ID。

```
$GRATING,<目标>,<子命令>,<参数...>;CCCC
```

#### 字段说明
- **目标**：光栅尺编号（G1-G6），或 ALL
- **子命令**：具体操作
- **参数**：根据子命令不同

#### 子命令列表

| 子命令        | 参数  | 说明        |
| ---------- | --- | --------- |
| HOME       | 无   | 找零        |
| GET_STATUS | 无   | 查询状态      |
| SET_ZERO   | 无   | 设置当前位置为零点 |

#### 指令示例
```
$GRATING,G1,HOME;A4A4
$GRATING,G3,GET_STATUS;23B2
$GRATING,ALL,SET_ZERO;BC32
```

#### 批量指令格式
同一主命令下，用 `|` 分隔多个操作：
```
$GRATING,<目标1>,<子命令1>,<参数1>|<目标2>,<子命令2>,<参数2>|...;CCCC
```

**批量示例**：
```
$GRATING,G1,HOME|G2,HOME|G3,HOME;61CA
$GRATING,G1,SET_ZERO|G2,SET_ZERO|G4,SET_ZERO;1780
```

**注意**：
- 下位机对每个光栅尺操作分别应答
- ALL指令会对所有光栅尺（G1-G6）分别应答，共6个应答

### 4.4 SYSTEM 指令格式

系统级操作，不涉及具体控制器或设备。

```
$SYSTEM,<子命令>,<参数...>;CCCC
```

#### 子命令列表

| 子命令             | 参数  | 说明                  |
| --------------- | --- | ------------------- |
| HELLO           | 无   | 握手连接                |
| GET_INFO        | 无   | 获取下位机信息             |
| RESET           | 无   | 复位下位机               |
| GET_CONTROLLERS | 无   | 获取所有控制器状态           |
| INIT            | 无   | 系统整体初始化（所有电机+光栅尺找零） |

#### 指令示例
```
$SYSTEM,HELLO;90AD
$SYSTEM,GET_INFO;B128
$SYSTEM,GET_CONTROLLERS;ADF2
$SYSTEM,INIT;08FD
```

#### INIT指令说明
**功能**：执行系统整体初始化，自动完成以下操作：
1. 所有电机找零（M1-M11, P1, S1-S3）
2. 所有光栅尺找零（G1-G6）

**执行顺序**：
- 下位机按预设顺序依次对各控制器和光栅尺执行找零
- 每个设备找零完成后立即发送该设备的应答
- 全部执行完后返回汇总应答

**应答机制**：
下位机依次发送每个设备的找零完成应答，最后发送汇总应答：
```
// 收到确认
$ACK;D350

// 每个电机找零完成应答（按执行顺序）
$OK,MOTOR,C1,M7,HOME_DONE,0.00;XXXX
$OK,MOTOR,C1,M8,HOME_DONE,0.00;XXXX
...（所有电机）

// 每个光栅尺找零完成应答
$OK,GRATING,G1,HOME_DONE,0;XXXX
$OK,GRATING,G2,HOME_DONE,0;XXXX
...（所有光栅尺）

// 最后发送汇总应答
$OK,SYSTEM,INIT,ALL_DONE;F49C
```

**失败情况**：
```
// 如果某个设备找零失败，该设备返回ERROR
$ERROR,E104,MOTOR_M7_HOME_FAILED;XXXX

// 继续执行其他设备找零...

// 最后汇总应答中指明有失败
$ERROR,E302,INIT_PARTIAL_FAILED_M7_G3;BA78
```

**注意**：
- 初始化耗时较长（15个电机+6个光栅尺，约30-90秒）
- 上位机可实时接收每个设备的找零完成应答，显示进度
- 即使部分设备失败，其他设备仍继续执行
- 最终汇总应答表示整体初始化结果

---

## 5. 应答报文详细设计

### 5.1 ACK应答（收到确认）

下位机收到指令后立即回复：
```
$ACK;D350
```

简单确认，表示指令格式正确、CRC校验通过，已进入处理流程。

### 5.2 OK应答（成功响应）

#### MOTOR指令应答
```
$OK,MOTOR,<控制器ID>,<目标>,<数据...>;CCCC
```

**示例**：
```
// 查询电机状态的应答
$OK,MOTOR,C1,M7,IDLE,25.30;17C1
// 字段：状态,当前位置

// 找零完成应答
$OK,MOTOR,C3,M1,HOME_DONE,0.00;F96A

// 运动完成应答
$OK,MOTOR,C1,M7,MOVE_DONE,35.50;D223

```

#### GRATING指令应答
```
$OK,GRATING,<目标>,<数据...>;CCCC
```

**示例**：
```
// 查询光栅尺状态
$OK,GRATING,G1,READY,12500000;7B75
// 字段：状态,当前读数（int32原始值）

// 找零完成
$OK,GRATING,G1,HOME_DONE,0;DF96
```

#### SYSTEM指令应答
```
$OK,SYSTEM,<子命令>,<数据...>;CCCC
```

**示例**：
```
// 握手应答
$OK,SYSTEM,HELLO,V1.2.5,PROTO_V1.0,READY;2DFD
// 字段：固件版本,协议版本,状态

// 获取信息应答
$OK,SYSTEM,GET_INFO,DEVICE_5M,SN202510001,UPTIME_3600;4AB6

// 获取控制器状态
$OK,SYSTEM,GET_CONTROLLERS,C1:OK|C2:OK|C3:ERROR|C4:OK|C5:OK|C6:OK;697F
```

### 5.3 ERROR应答（错误响应）

```
$ERROR,<错误码>,<描述>;CCCC
```

**示例**：
```
$ERROR,E001,CRC_CHECK_FAILED;9C19
$ERROR,E101,MOTOR_M1_TIMEOUT;FA8E
$ERROR,E201,GRATING_G3_READ_ERROR;A4A8
```

---

## 6. 光栅尺数据上传

### 6.1 二进制帧格式

下位机以固定频率（1kHz-5kHz）持续上传6个光栅尺数据。

```
+------+------+------+--------+---------+---------+
| SOF1 | SOF2 | LEN  | DATA   | CRC16_H | CRC16_L |
+------+------+------+--------+---------+---------+
| 0xAA | 0x55 | 1B   | 24B    | 1B      | 1B      |
+------+------+------+--------+---------+---------+
```

#### 字段说明

| 字段      | 长度  | 说明                    |
| ------- | --- | --------------------- |
| SOF1    | 1B  | 帧头1，固定 0xAA           |
| SOF2    | 1B  | 帧头2，固定 0x55           |
| LEN     | 1B  | 数据段长度（固定 0x18 = 24字节） |
| DATA    | 24B | 6个光栅尺读数，每个4字节int32小端序 |
| CRC16_H | 1B  | CRC16高字节              |
| CRC16_L | 1B  | CRC16低字节              |

#### 数据段说明
- **光栅尺顺序**：G1, G2, G3, G4, G5, G6
- **数据类型**：int32有符号整数（小端序）
- **单位**：0.1nm
- **范围**：±214.7mm（±2,147,483,647 × 0.1nm）

#### CRC16校验范围
从 `LEN` 开始到 `DATA` 结束，共25字节。

### 6.2 示例解析

假设接收到以下数据（十六进制）：
```
AA 55 18 [24字节光栅尺数据] A2 3F
```

解析：
- `AA 55`：帧头
- `18`：数据长度24字节（0x18 = 24）
- 接下来24字节：6个int32（小端序）
  - G1（4字节）：如 `00 7A 12 00`（小端序）= 0x00127A00 = 1,210,880（即 1210880×0.1nm = 121.088mm）
  - G2（4字节）
  - G3（4字节）
  - G4（4字节）
  - G5（4字节）
  - G6（4字节）
- `A2 3F`：CRC16（大端序，高字节在前，值为0xA23F）

### 6.3 未来扩展说明

如需上传其他二进制数据（如传感器、温度等），可通过以下方式扩展：
1. 使用不同的帧头（如 `0xBB 0x66`）
2. 或在LEN字段后增加TYPE字段
3. 保持帧格式一致性

---

## 7. CRC16校验

### 7.1 算法参数

- **多项式**：0x8005（CRC-16-ANSI / CRC-16-IBM）
- **初始值**：0xFFFF
- **结果异或值**：0x0000
- **输入反转**：是
- **输出反转**：是

### 7.2 C语言参考实现

```c
uint16_t crc16(const uint8_t *data, uint16_t len) {
    uint16_t crc = 0xFFFF;
    for (uint16_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc = (crc >> 1) ^ 0xA001;
            } else {
                crc = crc >> 1;
            }
        }
    }
    return crc;
}
```

**注意**：
- 文档中的所有CRC示例值均为真实计算值
- 提供了Python版CRC16计算工具（`crc16_calculator.py`）可用于验证和调试
- 运行工具：`python crc16_calculator.py` 进入交互式计算模式

### 7.3 字符串指令CRC计算

**校验范围**：从 `$` 之后到 `;` 之前的所有字符（不含帧头和帧尾）。

**示例**：
```
原始指令：$MOTOR,C1,M7,MOVE_REL,10.5;
校验数据：MOTOR,C1,M7,MOVE_REL,10.5
CRC16计算结果：0x8BF8
最终发送：$MOTOR,C1,M7,MOVE_REL,10.5;8BF8
```

**注意**：
- CRC值用4位十六进制大写字符表示
- 字符串形式，高位在前（如 0xA3F2 → "A3F2"）

### 7.4 二进制数据CRC计算

**校验范围**：从 `LEN` 到 `DATA` 结束（25字节）。

**字节序**：大端序，高字节在前。

**示例**：
```
假设CRC16计算结果：0xA3F2
发送字节序：[0xA3][0xF2]（高字节在前）
```

**注意**：统一使用大端序（高字节在前），与字符串CRC的显示顺序一致。

---

## 8. 状态码定义

### 8.1 设备状态

| 状态码        | 说明        |
| ---------- | --------- |
| IDLE       | 空闲，可接受新指令 |
| RUNNING    | 运行中       |
| HOMING     | 找零中       |
| ERROR      | 故障        |
| READY      | 就绪        |
| BUSY       | 忙碌        |
| HOME_DONE  | 找零完成      |
| MOVE_DONE  | 运动完成      |
| LEFT_DONE  | 到达左极限     |
| RIGHT_DONE | 到达右极限     |

### 8.2 错误码

| 错误码  | 说明                |
| ---- | ----------------- |
| E001 | CRC校验失败           |
| E002 | 指令格式错误            |
| E003 | 不支持的指令            |
| E004 | 参数超出范围            |
| E005 | 控制器ID不存在          |
| E006 | 设备编号不存在           |
| E101 | 电机超时              |
| E102 | 电机失步              |
| E103 | 电机限位触发            |
| E104 | 电机未找零 / 找零失败      |
| E105 | 电机忙碌              |
| E201 | 光栅尺读数异常           |
| E202 | 光栅尺未找零 / 找零失败     |
| E203 | 光栅尺通信故障           |
| E301 | 控制器无应答            |
| E302 | 控制器硬件故障 / 系统初始化失败 |
| E303 | 控制器忙碌             |
| E999 | 未知错误              |

---

## 9. 通信流程示例

### 9.1 系统启动连接

```
上位机 → $SYSTEM,HELLO;90AD
下位机 → $ACK;D350
下位机 → $OK,SYSTEM,HELLO,V1.2.5,PROTO_V1.0,READY;2DFD
上位机 → $SYSTEM,GET_CONTROLLERS;ADF2
下位机 → $ACK;D350
下位机 → $OK,SYSTEM,GET_CONTROLLERS,C1:OK|C2:OK|C3:OK|C4:OK|C5:OK|C6:OK;8EE6
```

**连接后初始化（成功）**：
```
上位机 → $SYSTEM,INIT;08FD
下位机 → $ACK;D350
（下位机开始执行所有设备找零...）
下位机 → $OK,MOTOR,C1,M7,HOME_DONE,0.00;E390
下位机 → $OK,MOTOR,C1,M8,HOME_DONE,0.00;17D5
下位机 → $OK,MOTOR,C1,M9,HOME_DONE,0.00;8714
下位机 → $OK,MOTOR,C2,M10,HOME_DONE,0.00;D37B
下位机 → $OK,MOTOR,C2,M11,HOME_DONE,0.00;43BA
...（所有11个电机+1个转盘+3个螺钉）
下位机 → $OK,GRATING,G1,HOME_DONE,0;DF96
下位机 → $OK,GRATING,G2,HOME_DONE,0;1C93
下位机 → $OK,GRATING,G3,HOME_DONE,0;9D91
下位机 → $OK,GRATING,G4,HOME_DONE,0;DA9A
下位机 → $OK,GRATING,G5,HOME_DONE,0;5B98
下位机 → $OK,GRATING,G6,HOME_DONE,0;989D
（所有设备找零完成，约30-90秒）
下位机 → $OK,SYSTEM,INIT,ALL_DONE;F49C
```

**初始化部分失败示例**：
```
上位机 → $SYSTEM,INIT;08FD
下位机 → $ACK;D350
（初始化开始...）
下位机 → $OK,MOTOR,C1,M7,HOME_DONE,0.00;E390
下位机 → $ERROR,E104,MOTOR_M8_HOME_FAILED;E9F3
下位机 → $OK,MOTOR,C1,M9,HOME_DONE,0.00;8714
...（继续其他设备）
下位机 → $OK,GRATING,G1,HOME_DONE,0;DF96
下位机 → $OK,GRATING,G2,HOME_DONE,0;1C93
下位机 → $ERROR,E202,GRATING_G3_HOME_FAILED;62FC
...（继续其他设备）
下位机 → $ERROR,E302,INIT_PARTIAL_FAILED_M8_G3;3177
```

### 9.2 单个电机运动

```
上位机 → $MOTOR,C1,M7,MOVE_REL,10.5;8BF8
下位机 → $ACK;D350
（电机运动中...）
下位机 → $OK,MOTOR,C1,M7,MOVE_DONE,35.50;D223
```

### 9.3 批量电机运动

**同一控制器批量**：
```
上位机 → $MOTOR,C1,M7,MOVE_REL,10.0|C1,M8,MOVE_REL,15.5|C1,M9,STOP;7775
下位机 → $ACK;D350
（电机运动中...）
下位机 → $OK,MOTOR,C1,M7,MOVE_DONE,45.00;4295
下位机 → $OK,MOTOR,C1,M8,MOVE_DONE,60.50;EDDA
下位机 → $OK,MOTOR,C1,M9,MOVE_DONE,30.00;2D44
```

**跨控制器批量（多轴协同）**：
```
上位机 → $MOTOR,C1,M7,MOVE_REL,10.0|C2,M10,MOVE_ABS,50.0|C3,M1,MOVE_REL,5.0;9778
下位机 → $ACK;D350
（多个控制器电机同时运动...）
下位机 → $OK,MOTOR,C1,M7,MOVE_DONE,35.00;8220
下位机 → $OK,MOTOR,C2,M10,MOVE_DONE,50.00;01D8
下位机 → $OK,MOTOR,C3,M1,MOVE_DONE,25.50;5184
```

### 9.4 电机找零

```
上位机 → $MOTOR,C3,M1,HOME;3D3C
下位机 → $ACK;D350
（找零中...）
下位机 → $OK,MOTOR,C3,M1,HOME_DONE,0.00;F96A
```

### 9.5 光栅尺找零

```
上位机 → $GRATING,G1,HOME;A4A4
下位机 → $ACK;D350
（找零中...）
下位机 → $OK,GRATING,G1,HOME_DONE,0;DF96
```

### 9.6 查询状态

```
上位机 → $MOTOR,C1,M7,GET_STATUS;E9C1
下位机 → $ACK;D350
下位机 → $OK,MOTOR,C1,M7,IDLE,25.30;17C1

上位机 → $GRATING,G3,GET_STATUS;23B2
下位机 → $ACK;D350
下位机 → $OK,GRATING,G3,READY,8750000;E18E
```

### 9.7 ALL指令示例

```
上位机 → $MOTOR,C1,ALL,STOP;2A99
下位机 → $ACK;D350
（C1控制器下所有电机停止：M7, M8, M9）
下位机 → $OK,MOTOR,C1,M7,MOVE_DONE,10.00;8E59
下位机 → $OK,MOTOR,C1,M8,MOVE_DONE,15.50;E16F
下位机 → $OK,MOTOR,C1,M9,MOVE_DONE,20.30;1D79
```

### 9.8 批量指令部分失败

```
上位机 → $MOTOR,C1,M7,MOVE_REL,10.0|C1,M8,MOVE_REL,15.5|C1,M9,MOVE_REL,20.0;A8DA
下位机 → $ACK;D350
（M7正常，M8超限位，M9正常）
下位机 → $OK,MOTOR,C1,M7,MOVE_DONE,35.00;8220
下位机 → $ERROR,E103,MOTOR_M8_LIMIT_TRIGGER;4EAE
下位机 → $OK,MOTOR,C1,M9,MOVE_DONE,50.00;2DCC
```
**说明**：某个操作失败不影响其他操作的执行和应答。

### 9.9 错误处理

```
上位机 → $MOTOR,C1,M7,MOVE_REL,999999.9;E9CB（超出范围）
下位机 → $ACK;D350
下位机 → $ERROR,E004,PARAM_OUT_OF_RANGE;CF0A

上位机 → $MOTOR,C1,M7,MOVE_REL,10.5;8BF8
下位机 → $ACK;D350
（运动中出现限位...）
下位机 → $ERROR,E103,MOTOR_M7_LIMIT_TRIGGER;4AE1
```

### 9.10 光栅尺数据持续上传

无论上位机是否发送指令，下位机始终以固定频率（1kHz-5kHz）持续上传：

```
下位机 → [AA 55 18 ... 24字节数据 ... CRC_H CRC_L]
下位机 → [AA 55 18 ... 24字节数据 ... CRC_H CRC_L]
下位机 → [AA 55 18 ... 24字节数据 ... CRC_H CRC_L]
...（持续不断）
```

---

## 10. 扩展性设计

### 10.1 新增子命令
在现有主命令下直接添加新子命令，帧格式不变。

**示例**：未来增加速度控制
```
$MOTOR,C1,M7,MOVE_REL_V,10.5,5.0,2.0;07B6
// 增加速度和加速度参数
```

### 10.2 新增主命令
定义新的主命令类型。

**示例**：传感器模块
```
$SENSOR,<传感器ID>,<子命令>,<参数>;CCCC
```

### 10.3 新增二进制数据类型
使用不同的帧头或修改帧结构。

**示例1**：使用不同帧头
```
温度数据：[BB 66][LEN][DATA][CRC16]
```

**示例2**：增加TYPE字段
```
[AA 55][LEN][TYPE][DATA][CRC16]
```

### 10.4 协议版本兼容
握手时下位机上报协议版本，上位机根据版本适配不同指令集。

---

## 11. 波特率选择建议

### 11.1 数据量估算

**光栅尺数据帧大小**：
- 帧头：2字节
- LEN：1字节
- DATA：24字节
- CRC16：2字节
- **总计：29字节**

**串口传输**：
- 每字节10位（1起始位+8数据位+1停止位）
- 每帧：29 × 10 = 290位

### 11.2 频率与波特率

| 上传频率 | 数据量（bps） | 建议波特率 | 余量 |
|---------|--------------|-----------|------|
| 1kHz | 290k | 921600 | 3.2倍 |
| 2kHz | 580k | 1Mbaud | 1.7倍 |
| 5kHz | 1.45M | 2Mbaud | 1.4倍 |
| 5kHz | 1.45M | 3Mbaud | 2.1倍 |

**建议**：
- 1kHz频率：使用 921600 bps
- 2-5kHz频率：使用 2Mbaud 或 3Mbaud
- 预留余量给控制指令和应答报文

---

## 12. 实现注意事项

### 12.1 下位机实现

1. **帧解析**：
   - 字符串指令：状态机解析，识别 `$` 和 `;`
   - 二进制数据：DMA接收，识别 `0xAA 0x55`

2. **指令队列**：
   - 使用队列缓存待执行指令
   - 按FIFO顺序执行

3. **应答机制**：
   - 收到指令立即发送ACK
   - 执行完成后发送OK或ERROR
   - 异常情况主动上报ERROR

4. **光栅尺上传**：
   - 使用定时器触发，独立于指令处理
   - 优先级最高，保证实时性
   - 建议使用DMA+双缓冲

5. **控制器通信**：
   - 下位机作为主控，转发指令给对应控制器
   - 超时处理：控制器无应答时返回E301

### 12.2 上位机实现

1. **线程分离**：
   - 发送线程：处理用户指令
   - 接收线程：解析应答和光栅尺数据
   - 避免阻塞

2. **数据解析**：
   - 区分字符串帧（`$`开头）和二进制帧（`0xAA 0x55`开头）
   - CRC校验失败直接丢弃

3. **指令响应**：
   - 超时机制：发送指令后等待ACK，超时重发
   - 应答匹配：根据主命令、控制器ID、目标匹配响应

4. **光栅尺数据**：
   - 高频数据流，使用环形缓冲区
   - 定期读取最新数据，避免累积

5. **错误处理**：
   - 记录ERROR应答，提示用户
   - 严重错误停止发送新指令

---

## 附录A：快速参考

### 指令格式速查

| 指令类型 | 格式                                 | 示例                                               |
| ---- | ---------------------------------- | ------------------------------------------------ |
| 电机控制 | `$MOTOR,<CID>,<目标>,<子命令>,<参数>;CRC` | `$MOTOR,C1,M7,MOVE_REL,10.5;8BF8`                |
| 光栅尺  | `$GRATING,<目标>,<子命令>,<参数>;CRC`     | `$GRATING,G1,HOME;A4A4`                          |
| 系统   | `$SYSTEM,<子命令>,<参数>;CRC`           | `$SYSTEM,HELLO;90AD`                             |
| 批量   | 用 `\|` 分隔，可跨控制器                    | `$MOTOR,C1,M7,STOP\|C1,M8,STOP\|C2,M9,STOP;5AE0` |

### 应答格式速查

| 应答类型 | 格式 | 示例 |
|---------|------|------|
| ACK | `$ACK;CRC` | `$ACK;D350` |
| OK | `$OK,<主命令>,<数据>;CRC` | `$OK,MOTOR,C1,M7,IDLE,25.3;0105` |
| ERROR | `$ERROR,<错误码>,<描述>;CRC` | `$ERROR,E101,MOTOR_TIMEOUT;35B6` |

### 数据类型速查

| 类型 | 大小 | 格式 | 用途 |
|-----|------|------|------|
| int32 | 4B | 小端序 | 光栅尺读数（0.1nm单位） |
| float | - | 字符串 | 电机位置/位移（mm或度） |
| char[] | 可变 | ASCII | 指令字符串 |

---

**协议版本**：V1.0  
**最后更新**：2025-10-31
