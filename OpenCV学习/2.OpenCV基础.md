# OpenCV基础
## 图像IO操作

这是学OpenCV的第一步，得先会读、显示、保存图片才能继续操作。

### 1. 读取图像 - ==cv2.imread()==

**基本用法：**
```python
import cv2

# 读取图片（默认是彩色模式）
img = cv2.imread('图片路径.jpg')

# 读取灰度图
img_gray = cv2.imread('图片路径.jpg', cv2.IMREAD_GRAYSCALE)
# 或者简写成数字：0表示灰度，1表示彩色
img_gray = cv2.imread('图片路径.jpg', 0)
```

**函数参数说明：**
```python
cv2.imread(filename, flags=cv2.IMREAD_COLOR)
```
- ==`filename`==：图片路径（字符串）
- ==`flags`==：读取模式（可选）
  - `cv2.IMREAD_COLOR` 或 `1`：彩色模式（==默认==），读成==BGR格式==
  - `cv2.IMREAD_GRAYSCALE` 或 `0`：灰度模式
  - `cv2.IMREAD_UNCHANGED` 或 `-1`：包含alpha通道
- **返回值**：图像的NumPy数组，失败返回 `None`

**注意事项：**
- ==OpenCV读取的彩色图是 **BGR格式**（蓝绿红），不是常见的RGB格式！==
- 如果图片路径不存在，==不会报错==，但返回 `None`
- 中文路径可能出问题，建议用英文路径

**检查是否读取成功：**
```python
img = cv2.imread('tt.png')
if img is None:
    print('图片读取失败，检查路径是否正确')
else:
    print('图片读取成功')
    print(f'图片大小：{img.shape}')  # (高度, 宽度, 通道数)
```

![[Pasted image 20251020110434.png]]

### 2. 显示图像 - ==cv2.imshow()==

**用OpenCV显示：**
```python
import cv2

img = cv2.imread('test.jpg')

# 显示图片
cv2.imshow('窗口名字', img)  # 第一个参数是窗口标题

# ==等待按键（必须加！不加的话窗口一闪就没了）==
cv2.waitKey(0)  # ==0表示无限等待==，直到按任意键
# cv2.waitKey(5000)  # 也可以指定等待时间，比如5000毫秒=5秒

# 关闭所有窗口
cv2.destroyAllWindows()
```

**函数参数说明：**
```python
cv2.imshow(winname, mat)
cv2.waitKey(delay=0)
cv2.destroyAllWindows()
```
- ==`cv2.imshow()`== 参数：
  - `winname`：窗口名字（字符串）
  - `mat`：要显示的图像（NumPy数组）
  
- ==`cv2.waitKey()`== 参数：
  - `delay`：等待时间（毫秒）
  - `0`：==无限等待==，直到按键
  - `>0`：等待指定毫秒，超时自动关闭
  - **返回值**：按键的ASCII码，超时返回 `-1`
  
- ==`cv2.destroyAllWindows()`==：关闭所有OpenCV窗口

**用Matplotlib显示（推荐在notebook里用）：**
```python
import cv2
import matplotlib.pyplot as plt

img = cv2.imread('test.jpg')

# ==OpenCV读的是BGR，要转成RGB才能正确显示==
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.imshow(img_rgb)
plt.title('我的图片')
plt.axis('off')  # 不显示坐标轴
plt.show()
```

==**cv2.cvtColor() 参数说明：**==
```python
cv2.cvtColor(src, code)
```
- ==`src`==：源图像
- ==`code`==：颜色转换代码，常用的有：
  - `cv2.COLOR_BGR2RGB`：BGR转RGB（matplotlib用）
  - `cv2.COLOR_BGR2GRAY`：BGR转灰度
  - `cv2.COLOR_GRAY2BGR`：灰度转BGR
  - `cv2.COLOR_BGR2HSV`：BGR转HSV色彩空间
  - `cv2.COLOR_HSV2BGR`：HSV转BGR
- **返回值**：转换后的图像

![[Pasted image 20251020134752.png]]
**显示多张图片对比：**
```python
import cv2
import matplotlib.pyplot as plt

# 先读取一张图片
img = cv2.imread('tt.png')  # 用你的图片路径

# 转换成RGB（matplotlib要用）
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 转换成灰度图
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 做一些简单处理，比如模糊
img_blur = cv2.GaussianBlur(img, (15, 15), 0)
img_blur_rgb = cv2.cvtColor(img_blur, cv2.COLOR_BGR2RGB)

# 现在显示三张图对比
fig, axes = plt.subplots(1, 3, figsize=(15, 5))
axes[0].imshow(img_rgb); axes[0].set_title('原图')
axes[1].imshow(img_gray, cmap='gray'); axes[1].set_title('灰度图')
axes[2].imshow(img_blur_rgb); axes[2].set_title('模糊处理')

# 关闭坐标轴
for ax in axes:
    ax.axis('off')

plt.tight_layout()
plt.show()
```
![[Pasted image 20251020135027.png]]

### 3. 保存图像 - ==cv2.imwrite()==

**基本用法：**
```python
import cv2

img = cv2.imread('input.jpg')

# 对图片做一些处理...
# processed_img = ...

# 保存图片
cv2.imwrite('output.jpg', img)

# 保存为PNG格式（无损）
cv2.imwrite('output.png', img)
```

**函数参数说明：**
```python
cv2.imwrite(filename, img, params=None)
```
- ==`filename`==：保存路径（字符串），格式由扩展名决定
- ==`img`==：要保存的图像（NumPy数组）
- ==`params`==：格式相关参数（可选），以列表形式传入
  - `cv2.IMWRITE_JPEG_QUALITY`：JPG质量（0-100，默认95）
  - `cv2.IMWRITE_PNG_COMPRESSION`：PNG压缩（0-9，默认3）
- **返回值**：保存成功返回 `True`，失败返回 `False`

**设置保存质量（针对JPG）：**
```python
# 设置JPG压缩质量（==0-100，默认95==）
cv2.imwrite('output.jpg', img, [cv2.IMWRITE_JPEG_QUALITY, 90])

# 低质量（文件小）
cv2.imwrite('low_quality.jpg', img, [cv2.IMWRITE_JPEG_QUALITY, 50])

# 高质量（文件大）
cv2.imwrite('high_quality.jpg', img, [cv2.IMWRITE_JPEG_QUALITY, 100])
```

**设置PNG压缩级别：**
```python
# PNG压缩级别（0-9，0不压缩，9最大压缩）
cv2.imwrite('output.png', img, [cv2.IMWRITE_PNG_COMPRESSION, 9])
```

**注意事项：**
- 保存的格式由文件扩展名决定（.jpg、.png、.bmp等）
- 如果路径不存在，需要先创建文件夹
- 中文路径可能出问题

### 4. 完整示例 - 读取、处理、保存

```python
import cv2
import numpy as np

# 读取图片
img = cv2.imread('lena.jpg')

if img is None:
    print('图片读取失败！')
else:
    # 显示原图信息
    print(f'图片大小：{img.shape}')
    
    # 转换为灰度图
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # 显示原图和灰度图
    cv2.imshow('Original', img)
    cv2.imshow('Gray', gray)
    
    # 保存灰度图
    cv2.imwrite('lena_gray.jpg', gray)
    print('灰度图已保存')
    
    # 等待按键
    cv2.waitKey(0)
    cv2.destroyAllWindows()
```
![[Pasted image 20251020140329.png]]
![[Pasted image 20251020140417.png]]
### 小技巧

**1. 处理中文路径：**
```python
import cv2
import numpy as np

# 用numpy读取中文路径
img = cv2.imdecode(np.fromfile('中文路径/图片.jpg', dtype=np.uint8), cv2.IMREAD_COLOR)

# 保存到中文路径
cv2.imencode('.jpg', img)[1].tofile('中文路径/输出.jpg')
```

**2. 批量读取图片：**
```python
import cv2
import os

folder = 'images/'
for filename in os.listdir(folder):
    if filename.endswith('.jpg') or filename.endswith('.png'):
        img_path = os.path.join(folder, filename)
        img = cv2.imread(img_path)
        # 处理图片...
```

---

**小结：**
- ==`cv2.imread()`== - 读图片
- ==`cv2.imshow()`== - 显示图片（==记得加waitKey==）
- ==`cv2.imwrite()`== - 保存图片
- ==注意BGR和RGB的区别==
- 中文路径要特殊处理

---

## 在图像中绘制几何图形

OpenCV提供了丰富的绘图功能，可以在图像上绘制各种几何图形和文字，常用于标注、可视化等场景。

### 1. 绘制直线 - ==cv2.line()==

```python
import cv2
import numpy as np

# 创建一个黑色背景
img = np.zeros((512, 512, 3), dtype=np.uint8)

# 绘制一条红色直线
cv2.line(img, (50, 50), (400, 50), (0, 0, 255), 3)

# 绘制一条绿色斜线
cv2.line(img, (50, 100), (400, 400), (0, 255, 0), 5)

# 绘制虚线效果（用多条短线）
for i in range(0, 500, 20):
    cv2.line(img, (i, 200), (i+10, 200), (255, 0, 0), 3)

cv2.imshow('Lines', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.line(img, pt1, pt2, color, thickness, lineType)
```
- ==`img`==：要绘制的图像
- ==`pt1`==：起点坐标 `(x1, y1)`
- ==`pt2`==：终点坐标 `(x2, y2)`
- ==`color`==：线条颜色（BGR）`(B, G, R)`
- `thickness`：线宽（像素），默认1
- `lineType`：线型，可选：
  - `cv2.LINE_8`：8连接线（默认）
  - `cv2.LINE_4`：4连接线
  - `cv2.LINE_AA`：抗锯齿线（平滑）
![[Pasted image 20251020143149.png]]

### 2. 绘制矩形 - ==cv2.rectangle()==

```python
import cv2
import numpy as np

img = np.zeros((512, 512, 3), dtype=np.uint8)

# 绘制空心矩形（绿色，线宽2）
cv2.rectangle(img, (50, 50), (200, 150), (0, 255, 0), 2)

# 绘制实心矩形（蓝色，填充）
cv2.rectangle(img, (250, 50), (400, 150), (255, 0, 0), -1)

# 绘制圆角矩形（需要自己组合）
cv2.rectangle(img, (50, 200), (200, 350), (0, 255, 255), 3)

cv2.imshow('Rectangles', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.rectangle(img, pt1, pt2, color, thickness, lineType)
```
- ==`pt1`==：左上角坐标 `(x1, y1)`
- ==`pt2`==：右下角坐标 `(x2, y2)`
- ==`thickness`==：线宽，==-1表示填充==
![[Pasted image 20251020143426.png]]

### 3. 绘制圆形 - ==cv2.circle()==

```python
import cv2
import numpy as np

img = np.zeros((512, 512, 3), dtype=np.uint8)

# 绘制空心圆（红色，线宽3）
cv2.circle(img, (150, 150), 80, (0, 0, 255), 3)

# 绘制实心圆（绿色，填充）
cv2.circle(img, (350, 150), 60, (0, 255, 0), -1)

# 绘制同心圆
cv2.circle(img, (250, 350), 100, (255, 255, 0), 2)
cv2.circle(img, (250, 350), 70, (255, 255, 0), 2)
cv2.circle(img, (250, 350), 40, (255, 255, 0), 2)

cv2.imshow('Circles', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.circle(img, center, radius, color, thickness, lineType)
```
- ==`center`==：圆心坐标 `(x, y)`
- ==`radius`==：半径（像素）
- ==`thickness`==：线宽，==-1填充==

![[Pasted image 20251020143553.png]]

### 4. 绘制椭圆 - ==cv2.ellipse()==

```python
import cv2
import numpy as np

img = np.zeros((512, 512, 3), dtype=np.uint8)

# 绘制椭圆
cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 360, (255, 0, 0), 2)

# 绘制半椭圆（从0度到180度）
cv2.ellipse(img, (256, 100), (80, 40), 0, 0, 180, (0, 255, 0), 3)

# 绘制旋转的椭圆（旋转45度）
cv2.ellipse(img, (150, 350), (100, 50), 45, 0, 360, (0, 255, 255), 2)

# 绘制实心椭圆
cv2.ellipse(img, (350, 350), (80, 40), 0, 0, 360, (255, 0, 255), -1)

cv2.imshow('Ellipses', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness)
```
- ==`center`==：椭圆中心 `(x, y)`
- ==`axes`==：长短轴 `(长轴, 短轴)`
- ==`angle`==：椭圆旋转角度（顺时针）
- ==`startAngle`==：起始角度（0-360）
- ==`endAngle`==：结束角度（0-360）
- `color`：颜色（BGR）
- `thickness`：线宽，-1填充

![[Pasted image 20251020143716.png]]

### 5. 绘制多边形 - ==cv2.polylines()==

```python
import cv2
import numpy as np

img = np.zeros((512, 512, 3), dtype=np.uint8)

# 定义三角形的三个顶点
pts_triangle = np.array([[100, 100], [200, 50], [200, 150]], np.int32)
pts_triangle = pts_triangle.reshape((-1, 1, 2))
cv2.polylines(img, [pts_triangle], True, (0, 255, 0), 3)

# 定义五边形
pts_pentagon = np.array([[300, 100], [380, 140], [350, 220], [250, 220], [220, 140]], np.int32)
pts_pentagon = pts_pentagon.reshape((-1, 1, 2))
cv2.polylines(img, [pts_pentagon], True, (255, 0, 0), 2)

# 绘制填充多边形
pts_filled = np.array([[100, 300], [150, 250], [250, 300], [200, 400]], np.int32)
cv2.fillPoly(img, [pts_filled], (0, 255, 255))

cv2.imshow('Polygons', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.polylines(img, pts, isClosed, color, thickness)
cv2.fillPoly(img, pts, color)
```
- ==`pts`==：多边形顶点列表，格式：`[np.array([[x1,y1], [x2,y2], ...])]`
- ==`isClosed`==：是否闭合（True/False）
- `fillPoly()`：绘制填充多边形

![[Pasted image 20251020143947.png]]

### 6. 添加文字 - ==cv2.putText()==

```python
import cv2
import numpy as np

img = np.zeros((512, 512, 3), dtype=np.uint8)

# 添加不同字体的文字
font1 = cv2.FONT_HERSHEY_SIMPLEX
font2 = cv2.FONT_HERSHEY_PLAIN
font3 = cv2.FONT_HERSHEY_DUPLEX
font4 = cv2.FONT_HERSHEY_COMPLEX

cv2.putText(img, 'SIMPLEX', (10, 50), font1, 1, (255, 255, 255), 2)
cv2.putText(img, 'PLAIN', (10, 100), font2, 1.5, (0, 255, 0), 2)
cv2.putText(img, 'DUPLEX', (10, 150), font3, 1, (0, 255, 255), 2)
cv2.putText(img, 'COMPLEX', (10, 200), font4, 1, (255, 0, 255), 2)

# 添加大号文字
cv2.putText(img, 'OpenCV', (50, 300), cv2.FONT_HERSHEY_SIMPLEX, 2.5, (0, 0, 255), 5)

# 添加斜体文字
cv2.putText(img, 'Italic', (50, 400), cv2.FONT_HERSHEY_SIMPLEX | cv2.FONT_ITALIC, 
            1.5, (255, 255, 0), 3)

cv2.imshow('Text', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020144404.png]]
**函数参数：**
```python
cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType)
```
- ==`text`==：要显示的文字（==不支持中文==）
- ==`org`==：文字==左下角==坐标 `(x, y)`
- ==`fontFace`==：字体类型
- ==`fontScale`==：字体大小（缩放系数）
- `thickness`：字体粗细

**常用字体：**
- `cv2.FONT_HERSHEY_SIMPLEX`：正常大小无衬线字体
- `cv2.FONT_HERSHEY_PLAIN`：小号无衬线字体
- `cv2.FONT_HERSHEY_DUPLEX`：正常大小无衬线字体（较粗）
- `cv2.FONT_HERSHEY_COMPLEX`：正常大小有衬线字体
- `cv2.FONT_HERSHEY_TRIPLEX`：正常大小有衬线字体（较粗）
- `cv2.FONT_HERSHEY_SCRIPT_SIMPLEX`：手写风格字体
- 添加 `| cv2.FONT_ITALIC` 可以变成斜体

**显示中文的方法（使用PIL）：**
```python
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont

# 创建图像
img = np.zeros((200, 400, 3), dtype=np.uint8)

# 转换为PIL格式
img_pil = Image.fromarray(img)
draw = ImageDraw.Draw(img_pil)

# 使用中文字体（需要指定字体文件路径）
font = ImageFont.truetype("simhei.ttf", 40)  # 黑体
draw.text((50, 50), "你好，OpenCV！", font=font, fill=(255, 255, 255))

# 转回OpenCV格式
img = np.array(img_pil)

cv2.imshow('Chinese Text', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020144528.png]]

### 综合示例：绘制完整图形

```python
import cv2
import numpy as np

# 创建白色画布
img = np.ones((600, 800, 3), dtype=np.uint8) * 255

# 绘制房子
cv2.rectangle(img, (200, 250), (600, 550), (139, 69, 19), -1)  # 房子主体（棕色）
pts = np.array([[200, 250], [400, 100], [600, 250]], np.int32)  # 屋顶
cv2.fillPoly(img, [pts], (0, 0, 200))  # 红色屋顶

# 绘制门
cv2.rectangle(img, (350, 400), (450, 550), (0, 100, 0), -1)  # 绿色门

# 绘制窗户
cv2.rectangle(img, (250, 300), (330, 380), (135, 206, 250), -1)  # 左窗
cv2.rectangle(img, (470, 300), (550, 380), (135, 206, 250), -1)  # 右窗

# 绘制太阳
cv2.circle(img, (700, 100), 50, (0, 255, 255), -1)

# 绘制云朵（用多个圆组成）
cv2.circle(img, (100, 120), 30, (200, 200, 200), -1)
cv2.circle(img, (130, 110), 35, (200, 200, 200), -1)
cv2.circle(img, (160, 120), 30, (200, 200, 200), -1)

# 添加文字
cv2.putText(img, 'My House', (320, 580), cv2.FONT_HERSHEY_SIMPLEX, 
            1.5, (0, 0, 0), 3)

cv2.imshow('Drawing', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020144707.png]]

### 小结

| 函数 | 用途 | 关键参数 |
|------|------|----------|
| `cv2.line()` | 绘制直线 | 起点、终点 |
| `cv2.rectangle()` | 绘制矩形 | 左上角、右下角 |
| `cv2.circle()` | 绘制圆形 | 圆心、半径 |
| `cv2.ellipse()` | 绘制椭圆 | 中心、长短轴、角度 |
| `cv2.polylines()` | 绘制多边形 | 顶点列表 |
| `cv2.fillPoly()` | 填充多边形 | 顶点列表 |
| `cv2.putText()` | 添加文字 | 文字、左下角坐标、字体 |

**注意事项：**
- ==所有颜色都是BGR格式==
- ==thickness=-1 表示填充==
- ==putText不支持中文，需要用PIL==
- 坐标系原点在左上角，x向右，y向下

---

## 图像的基础操作

这一节主要讲解如何操作图像的基本属性、像素、通道等。

### 1. 获取图像属性

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 图像形状 (高度, 宽度, 通道数)
print(f'图像形状：{img.shape}')
height, width, channels = img.shape
print(f'高度：{height}, 宽度：{width}, 通道数：{channels}')

# 图像大小（像素总数）
print(f'图像大小：{img.size}')  # height × width × channels

# 数据类型
print(f'数据类型：{img.dtype}')  # 通常是uint8

# 图像的维度
print(f'图像维度：{img.ndim}')  # 彩色图是3，灰度图是2

# 每个像素的字节数
print(f'每个像素字节数：{img.itemsize}')  # uint8是1字节
```

**输出示例：**
```
图像形状：(480, 640, 3)
高度：480, 宽度：640, 通道数：3
图像大小：921600
数据类型：uint8
图像维度：3
每个像素字节数：1
```

> 💡 **重点**：
> - `shape` = ==(高度, 宽度, 通道数)==，注意是==高度在前==
> - `size` = 总像素数 = 高度 * 宽度 * 通道数
> - **灰度图没有通道数，shape只有2个值 `(高度, 宽度)**`

### 2. 访问和修改像素

```python
import cv2

img = cv2.imread('test.jpg')

# 访问单个像素（返回BGR值）
pixel = img[100, 200]  # [行, 列] = [y, x]
print(f'像素值（BGR）：{pixel}')  # 例如：[120, 150, 200]

# 访问单个通道的像素值
blue = img[100, 200, 0]   # B通道
green = img[100, 200, 1]  # G通道
red = img[100, 200, 2]    # R通道
print(f'B={blue}, G={green}, R={red}')

# 修改单个像素
img[100, 200] = [255, 255, 255]  # 改成白色

# 修改某个区域的像素
img[50:150, 100:200] = [0, 255, 0]  # 绘制绿色矩形

# 修改单个通道
img[200:300, 200:300, 0] = 255  # 只修改B通道，变成黄色区域

cv2.imshow('Modified', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**注意事项：**
- ==访问像素用 `img[y, x]` 或 `img[行, 列]`==
- ==像素值是BGR顺序==：`[B, G, R]`
- ==**批量修改用切片：`img[y1:y2, x1:x2]==`**
![[Pasted image 20251020145425.png]]

### 3. 提取ROI（感兴趣区域）

ROI（Region of Interest）就是从图像中提取一部分区域进行操作。

```python
import cv2

img = cv2.imread('test.jpg')

# 提取ROI区域（裁剪）
roi = img[100:300, 150:350]  # [y1:y2, x1:x2]

# 显示ROI
cv2.imshow('Original', img)
cv2.imshow('ROI', roi)

# 将ROI复制到其他位置
img[400:600, 400:600] = roi

# 对ROI进行处理
roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
roi_blur = cv2.GaussianBlur(roi, (15, 15), 0)

cv2.imshow('Result', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

![[Pasted image 20251020150036.png]]
![[Pasted image 20251020150050.png]]
### 4. 图像通道的拆分与合并

彩色图像由B、G、R三个通道组成，可以分开处理再合并。

**方法1：使用 ==cv2.split()== 和 ==cv2.merge()==**

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 拆分通道
b, g, r = cv2.split(img)

# 显示各个通道（都是灰度图）
cv2.imshow('Blue Channel', b)
cv2.imshow('Green Channel', g)
cv2.imshow('Red Channel', r)

# 合并通道
merged = cv2.merge([b, g, r])

# 调换通道顺序（BGR变成RGB）
rgb = cv2.merge([r, g, b])

# 只保留某个通道（其他通道置0）
zeros = np.zeros(img.shape[:2], dtype=np.uint8)
only_blue = cv2.merge([b, zeros, zeros])   # 只保留蓝色
only_green = cv2.merge([zeros, g, zeros])  # 只保留绿色
only_red = cv2.merge([zeros, zeros, r])    # 只保留红色

cv2.imshow('Only Blue', only_blue)
cv2.imshow('Only Green', only_green)
cv2.imshow('Only Red', only_red)

cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020151800.png]]
**方法2：使用NumPy切片（更快）**

```python
import cv2

img = cv2.imread('test.jpg')

# 提取通道
b = img[:, :, 0]  # 蓝色通道
g = img[:, :, 1]  # 绿色通道
r = img[:, :, 2]  # 红色通道

# 修改某个通道
img[:, :, 0] = 0  # 将蓝色通道置0

cv2.imshow('No Blue', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**性能对比：**
- `cv2.split()` / `cv2.merge()`：比较慢，但代码清晰
- NumPy切片：==更快==，推荐用于大图像

**函数参数：**
```python
cv2.split(img)
cv2.merge(channels)
```
- ==`cv2.split(img)`==：拆分通道
  - `img`：输入图像（3通道）
  - **返回值**：`(b, g, r)` 三个单通道数组
  
- ==`cv2.merge(channels)`==：合并通道
  - `channels`：通道列表 `[b, g, r]`
  - **返回值**：合并后的3通道图像

### 5. 色彩空间的转换 - ==cv2.cvtColor()==

OpenCV支持多种色彩空间的转换，常用的有BGR、RGB、灰度、HSV、LAB等。

**常用转换：**

```python
import cv2
import matplotlib.pyplot as plt

img = cv2.imread('test.jpg')

# BGR转RGB（matplotlib显示用）
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# BGR转灰度
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# BGR转HSV（色相、饱和度、明度）
img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# BGR转LAB（Lab色彩空间）
img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)

# 灰度转BGR（单通道变三通道）
img_bgr = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR)

# 显示对比
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes[0, 0].imshow(img_rgb); axes[0, 0].set_title('Original (RGB)')
axes[0, 1].imshow(img_gray, cmap='gray'); axes[0, 1].set_title('Grayscale')
axes[0, 2].imshow(img_hsv); axes[0, 2].set_title('HSV')
axes[1, 0].imshow(img_lab); axes[1, 0].set_title('LAB')

# 显示HSV各个通道
h, s, v = cv2.split(img_hsv)
axes[1, 1].imshow(s, cmap='gray'); axes[1, 1].set_title('HSV - Saturation')
axes[1, 2].imshow(v, cmap='gray'); axes[1, 2].set_title('HSV - Value')

for ax in axes.flat:
    ax.axis('off')
    
plt.tight_layout()
plt.show()
```
![[Pasted image 20251020152135.png]]
**HSV色彩空间详解：**

HSV比BGR更符合人类对颜色的感知：
- ==H（Hue）==：色相，表示颜色类型（0-180度）
  - 红色：0-10, 170-180
  - 绿色：40-80
  - 蓝色：100-130
- ==S（Saturation）==：饱和度，颜色的纯度（0-255）
  - 0：灰色
  - 255：纯色
- ==V（Value）==：明度，颜色的亮度（0-255）
  - 0：黑色
  - 255：最亮

**HSV的应用：颜色检测**

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# 定义颜色范围（检测红色）
lower_red = np.array([0, 50, 50])
upper_red = np.array([10, 255, 255])

# 创建掩码
mask = cv2.inRange(hsv, lower_red, upper_red)

# 应用掩码
result = cv2.bitwise_and(img, img, mask=mask)

cv2.imshow('Original', img)
cv2.imshow('Mask', mask)
cv2.imshow('Result', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.inRange(src, lowerb, upperb)
```
- ==`src`==：输入图像（通常是HSV格式）
- ==`lowerb`==：下限值（NumPy数组）`[H_min, S_min, V_min]`
- ==`upperb`==：上限值（NumPy数组）`[H_max, S_max, V_max]`
- **返回值**：二值掩码图像（在范围内的像素为255，否则为0）

![[Pasted image 20251020152528.png]]

**常用色彩空间转换代码：**

| **转换**          | **代码**                    | **用途**            |
| ----------- | --------------------- | ------------- |
| **BGR → RGB**   | **`cv2.COLOR_BGR2RGB`**   | **Matplotlib显示**  |
| **BGR → 灰度**    | **`cv2.COLOR_BGR2GRAY`**  | **简化处理**          |
| **BGR → HSV**   | **`cv2.COLOR_BGR2HSV`**   | **==颜色检测==（最常用）** |
| **BGR → LAB**   | **`cv2.COLOR_BGR2LAB`**   | **肤色检测**          |
| **BGR → YCrCb** | **`cv2.COLOR_BGR2YCrCb`** | **JPEG压缩**        |
| **灰度 → BGR**    | **`cv2.COLOR_GRAY2BGR`**  | **通道数匹配**         |
| **HSV → BGR**   | **`cv2.COLOR_HSV2BGR`**   | **还原颜色**          |

### 综合示例：通道操作和色彩转换

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 1. 拆分通道
b, g, r = cv2.split(img)

# 2. 增强某个通道（让图片偏蓝）
b = cv2.add(b, 50)  # 蓝色通道增加50
img_blue_enhanced = cv2.merge([b, g, r])

# 3. 交换通道（BGR变GBR，会变成奇怪的颜色）
img_swapped = cv2.merge([g, b, r])

# 4. 转HSV并增强饱和度
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
h, s, v = cv2.split(hsv)
s = cv2.add(s, 50)  # 增加饱和度
s = np.clip(s, 0, 255)  # 限制在0-255范围
hsv_enhanced = cv2.merge([h, s, v])
img_saturated = cv2.cvtColor(hsv_enhanced, cv2.COLOR_HSV2BGR)

# 显示结果
cv2.imshow('Original', img)
cv2.imshow('Blue Enhanced', img_blue_enhanced)
cv2.imshow('Channel Swapped', img_swapped)
cv2.imshow('Saturation Enhanced', img_saturated)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 6. 操作掩码（Mask）

**掩码（Mask）是一种二值图像，用于指定在哪些区域进行操作，哪些区域不操作。掩码为255（白色）的地方会被处理，掩码为0（黑色）的地方会被忽略。**

**基本概念：**
- ==**掩码是单通道灰度图（0或255）**==
- **==掩码为255的区域：执行操作==**
- **==掩码为0的区域：保持不变==**

**创建掩码示例：**

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 创建全零掩码
mask = np.zeros((h, w), dtype=np.uint8)

# 在掩码上绘制白色区域（要操作的区域）
cv2.circle(mask, (w//2, h//2), min(h, w)//3, 255, -1)

cv2.imshow('Mask', mask)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**应用3：反向掩码**

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 创建圆形掩码
mask = np.zeros((h, w), dtype=np.uint8)
cv2.circle(mask, (w//2, h//2), min(h, w)//3, 255, -1)

# 反向掩码（圆外的区域）
mask_inv = cv2.bitwise_not(mask)

# 圆内区域
fg = cv2.bitwise_and(img, img, mask=mask)

# 圆外区域
bg = cv2.bitwise_and(img, img, mask=mask_inv)

cv2.imshow('Foreground', fg)
cv2.imshow('Background', bg)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020161827.png]]

**小结：**
- **掩码是单通道二值图像（0或255）**
- **`mask=mask` 参数用于指定操作区域**
- `cv2.bitwise_not()` 可以反转掩码
- 常用于局部图像处理、ROI提取、图像合成

---

## 图像的算术运算

图像的算术运算用于调整亮度、对比度、图像叠加等操作。

### 1. 图像加法 - ==cv2.add()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 方法1：直接用NumPy加法（可能溢出）
img_numpy = img + 50  # 直接加，超过255会溢出（取模）
print(f'NumPy加法，[255,255,255] + 50 = {np.array([255,255,255], dtype=np.uint8) + 50}')

# 方法2：用cv2.add（自动截断到255）
img_cv = cv2.add(img, np.array([50, 50, 50], dtype=np.uint8))
print(f'cv2.add，[255,255,255] + 50 = {cv2.add(np.array([255,255,255], dtype=np.uint8), np.array([50,50,50], dtype=np.uint8))}')

# 推荐用法：调整亮度
brightness = 50
img_bright = cv2.add(img, np.array([brightness] * 3, dtype=np.uint8))

cv2.imshow('Original', img)
cv2.imshow('Brighter', img_bright)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**两种方法的区别：**
- ==NumPy加法==：溢出会回绕（255+50 = 49）
- ==cv2.add()==：溢出会饱和（255+50 = 255）⭐ 推荐

**函数参数：**
```python
cv2.add(src1, src2, dst=None, mask=None, dtype=None)
```
- ==`src1`==：第一张图像（NumPy数组）
- ==`src2`==：第二张图像或标量值
- `mask`：可选的掩码（只对mask非零的地方进行运算）
- **返回值**：运算结果，溢出自动饱和到255

### 2. 图像减法 - ==cv2.subtract()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 减少亮度
darkness = 50
img_dark = cv2.subtract(img, np.array([darkness] * 3, dtype=np.uint8))

# 计算两张图的差异
img1 = cv2.imread('img1.jpg')
img2 = cv2.imread('img2.jpg')
diff = cv2.subtract(img1, img2)  # 绝对差异用cv2.absdiff()

cv2.imshow('Original', img)
cv2.imshow('Darker', img_dark)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.subtract(src1, src2, dst=None, mask=None, dtype=None)
cv2.absdiff(src1, src2)  # 计算绝对差值
```
- ==`src1`==：第一张图像
- ==`src2`==：第二张图像或标量值
- ==`absdiff()`：计算 `|src1 - src2|` 的绝对差值==
- ==**返回值：运算结果，下溢自动饱和到0**==

### 3. 图像乘法和除法 - ==cv2.multiply==、==cv2.divide==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 乘法：增加对比度
img_mul = cv2.multiply(img, np.array([1.5, 1.5, 1.5]))  # 注意会溢出
img_mul = np.clip(img_mul, 0, 255).astype(np.uint8)

# 除法：降低对比度
img_div = cv2.divide(img, np.array([2.0, 2.0, 2.0])).astype(np.uint8)

cv2.imshow('Original', img)
cv2.imshow('Multiply', img_mul)
cv2.imshow('Divide', img_div)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.multiply(src1, src2, dst=None, scale=1.0, dtype=None)
cv2.divide(src1, src2, dst=None, scale=1.0, dtype=None)
```
- ==`src1`==：第一张图像
- ==`src2`==：第二张图像或标量值
- `scale`：缩放因子（可选）
- **注意**：乘法容易溢出，建议用 `np.clip()` 限制范围

### 4. 按位运算

**按位运算常用于制作蒙版、图像叠加等。**

```python
import cv2
import numpy as np

# 创建两张简单的图
img1 = np.zeros((300, 300), dtype=np.uint8)
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

img2 = np.zeros((300, 300), dtype=np.uint8)
cv2.circle(img2, (150, 150), 100, 255, -1)

# 按位与（AND）- 交集
bitwise_and = cv2.bitwise_and(img1, img2)

# 按位或（OR）- 并集
bitwise_or = cv2.bitwise_or(img1, img2)

# 按位异或（XOR）- 不重叠的部分
bitwise_xor = cv2.bitwise_xor(img1, img2)

# 按位非（NOT）- 反转
bitwise_not = cv2.bitwise_not(img1)

# 显示结果
import matplotlib.pyplot as plt
fig, axes = plt.subplots(2, 3, figsize=(12, 8))
axes[0, 0].imshow(img1, cmap='gray'); axes[0, 0].set_title('Image 1')
axes[0, 1].imshow(img2, cmap='gray'); axes[0, 1].set_title('Image 2')
axes[0, 2].imshow(bitwise_and, cmap='gray'); axes[0, 2].set_title('AND')
axes[1, 0].imshow(bitwise_or, cmap='gray'); axes[1, 0].set_title('OR')
axes[1, 1].imshow(bitwise_xor, cmap='gray'); axes[1, 1].set_title('XOR')
axes[1, 2].imshow(bitwise_not, cmap='gray'); axes[1, 2].set_title('NOT')
for ax in axes.flat: ax.axis('off')
plt.tight_layout()
plt.show()
```
![[Pasted image 20251020155904.png]]
**函数参数：**
```python
cv2.bitwise_and(src1, src2, dst=None, mask=None)
cv2.bitwise_or(src1, src2, dst=None, mask=None)
cv2.bitwise_xor(src1, src2, dst=None, mask=None)
cv2.bitwise_not(src, dst=None, mask=None)
```
- ==`src1, src2`==：输入图像
- ==`mask`==：可选的操作掩码
- **返回值**：按位运算结果

**按位运算说明：**
- **`AND`：两个都是1才是1（==交集==）**
- **`OR`：有一个是1就是1（==并集==）**
- **`XOR`：不同为1，相同为0（==差集==）**
- **`NOT`：0变1，1变0（==反转==）**


**按位运算的应用：图像蒙版**

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 创建圆形蒙版
mask = np.zeros((h, w), dtype=np.uint8)
cv2.circle(mask, (w//2, h//2), min(h, w)//3, 255, -1)

# 应用蒙版（只保留圆形区域）
result = cv2.bitwise_and(img, img, mask=mask)

cv2.imshow('Original', img)
cv2.imshow('Mask', mask)
cv2.imshow('Result', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

![[Pasted image 20251020160111.png]]

### 5. 图像混合（融合）

图像混合可以实现两张图的叠加、淡入淡出等效果。

**5.1 基本混合 - ==cv2.addWeighted()==**

```python
import cv2

# 读取两张大小相同的图片
img1 = cv2.imread('img1.jpg')
img2 = cv2.imread('img2.jpg')

# 确保两张图大小一致
img2 = cv2.resize(img2, (img1.shape[1], img1.shape[0]))

# ==混合公式：result = img1 * α + img2 * β + γ==
alpha = 0.7  # img1的权重
beta = 0.3   # img2的权重
gamma = 0    # 亮度调节值

blended = cv2.addWeighted(img1, alpha, img2, beta, gamma)

cv2.imshow('Image 1', img1)
cv2.imshow('Image 2', img2)
cv2.imshow('Blended', blended)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.addWeighted(src1, alpha, src2, beta, gamma)
```
- ==`src1`==：第一张图
- ==`alpha`==：第一张图的权重（0.0-1.0）
- ==`src2`==：第二张图
- ==`beta`==：第二张图的权重（0.0-1.0）
- ==`gamma`==：亮度调节值（通常为0）
- **公式**：`result = src1 × alpha + src2 × beta + gamma`

![[Pasted image 20251020162358.png]]

**5.2 渐变过渡效果**

```python
import cv2
import numpy as np

img1 = cv2.imread('img1.jpg')
img2 = cv2.imread('img2.jpg')
img2 = cv2.resize(img2, (img1.shape[1], img1.shape[0]))

# 创建多个不同权重的混合图像（从img1渐变到img2）
for i in range(11):
    alpha = 1.0 - (i * 0.1)  # 从1.0到0.0
    beta = i * 0.1            # 从0.0到1.0
    
    blended = cv2.addWeighted(img1, alpha, img2, beta, 0)
    cv2.imshow('Transition', blended)
    cv2.waitKey(200)  # 每张显示200ms

cv2.destroyAllWindows()
```
---

## 边界填充

边界填充常用于图像滤波、卷积等操作，防止边缘信息丢失。

### 1. 基本填充 - ==cv2.copyMakeBorder()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')

# 定义填充大小
top, bottom, left, right = 50, 50, 50, 50

# ==不同的填充方式==

# 1. 常数填充（用指定颜色填充）
constant = cv2.copyMakeBorder(img, top, bottom, left, right, 
                              cv2.BORDER_CONSTANT, value=[255, 0, 0])

# 2. 复制边缘像素
replicate = cv2.copyMakeBorder(img, top, bottom, left, right, 
                               cv2.BORDER_REPLICATE)

# 3. 反射填充（边缘像素镜像）
reflect = cv2.copyMakeBorder(img, top, bottom, left, right, 
                            cv2.BORDER_REFLECT)

# 4. 反射填充101（不重复边缘像素）
reflect_101 = cv2.copyMakeBorder(img, top, bottom, left, right, 
                                cv2.BORDER_REFLECT_101)

# 5. 环绕填充
wrap = cv2.copyMakeBorder(img, top, bottom, left, right, 
                         cv2.BORDER_WRAP)

# 显示对比
import matplotlib.pyplot as plt
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes[0, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[0, 0].set_title('Original')
axes[0, 1].imshow(cv2.cvtColor(constant, cv2.COLOR_BGR2RGB))
axes[0, 1].set_title('CONSTANT')
axes[0, 2].imshow(cv2.cvtColor(replicate, cv2.COLOR_BGR2RGB))
axes[0, 2].set_title('REPLICATE')
axes[1, 0].imshow(cv2.cvtColor(reflect, cv2.COLOR_BGR2RGB))
axes[1, 0].set_title('REFLECT')
axes[1, 1].imshow(cv2.cvtColor(reflect_101, cv2.COLOR_BGR2RGB))
axes[1, 1].set_title('REFLECT_101')
axes[1, 2].imshow(cv2.cvtColor(wrap, cv2.COLOR_BGR2RGB))
axes[1, 2].set_title('WRAP')
for ax in axes.flat: ax.axis('off')
plt.tight_layout()
plt.show()
```

**函数参数：**
```python
cv2.copyMakeBorder(src, top, bottom, left, right, borderType, value)
```
- ==`src`==：源图像
- ==`top, bottom, left, right`==：各边填充的像素数
- ==`borderType`==：填充类型
- `value`：常数填充时的颜色值（可选）

**填充类型详解：**

| 类型 | 说明 | 示例（边缘是abc） |
|------|------|------------------|
| `BORDER_CONSTANT` | 常数填充 | `iiiiabcjjjj`（i和j是指定颜色） |
| `BORDER_REPLICATE` | ==复制边缘==（最常用） | `aaaaabccccc` |
| `BORDER_REFLECT` | 镜像反射 | `cbaaabccba` |
| `BORDER_REFLECT_101` | 镜像反射（不重复边缘） | `dcbabcbcd` |
| `BORDER_WRAP` | 环绕 | `bcabcabc` |
![[Pasted image 20251020163209.png]]

### 2. 实际应用示例

**应用1：给图片加边框**

```python
import cv2

img = cv2.imread('test.jpg')

# 加蓝色边框
bordered = cv2.copyMakeBorder(img, 20, 20, 20, 20, 
                             cv2.BORDER_CONSTANT, value=[255, 0, 0])

cv2.imshow('With Border', bordered)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 小结

**图像基础操作：**
- `shape`：==(高度, 宽度, 通道数)==
- `size`：总像素数
- `dtype`：数据类型（通常uint8）

**像素操作：**
- 访问：`img[y, x]` 或 `img[y, x, channel]`
- 修改：`img[y, x] = [B, G, R]`
- ROI：`roi = img[y1:y2, x1:x2]`

**通道操作：**
- 拆分：`b, g, r = cv2.split(img)`
- 合并：`img = cv2.merge([b, g, r])`
- 快速提取：`b = img[:, :, 0]`

**色彩空间：**
- BGR ↔ RGB：Matplotlib显示
- BGR → 灰度：简化处理
- BGR → HSV：==颜色检测==（最重要）
- `cv2.cvtColor(img, code)`

**操作掩码：**
- 掩码是单通道二值图（0或255）
- ==掩码为255的区域会被处理==
- `mask=mask` 参数用于指定操作区域
- `cv2.bitwise_not()` 反转掩码

**算术运算：**
- 加法：`cv2.add()` - ==自动饱和==（推荐）
- 减法：`cv2.subtract()` - 减少亮度
- 按位运算：`bitwise_and/or/xor/not` - 制作蒙版

**图像混合：**
- `cv2.addWeighted(img1, α, img2, β, γ)` - 图像融合
- 公式：`result = img1 × α + img2 × β + γ`
- 应用：淡入淡出、水印叠加

**边界填充：**
- `cv2.copyMakeBorder()` - 添加边界
- `BORDER_REPLICATE` - ==复制边缘==（最常用）
- `BORDER_REFLECT` - 镜像反射
- `BORDER_CONSTANT` - 常数填充

---

## 常用函数速查表

| 函数 | 作用 | 关键参数 | 备注 |
|------|------|----------|------|
| `cv2.imread(path, flag)` | 读取图片 | `flag`: 0灰度, 1彩色, -1含透明 | 返回BGR格式 |
| `cv2.imshow(name, img)` | 显示图片 | `name`: 窗口名 | ==必须配合waitKey== |
| `cv2.imwrite(path, img, params)` | 保存图片 | `params`: 质量参数 | 格式由扩展名定 |
| `cv2.waitKey(delay)` | 等待按键 | `delay`: 0无限等待 | 返回按键ASCII码 |
| `cv2.cvtColor(src, code)` | 颜色转换 | `code`: 转换代码 | BGR↔RGB常用 |
| `cv2.rectangle(img, pt1, pt2, color, thick)` | 画矩形 | `thick`: -1填充 | 颜色用BGR |
| `cv2.circle(img, center, r, color, thick)` | 画圆形 | `r`: 半径 | 颜色用BGR |
| `cv2.putText(img, text, org, font, scale, color, thick)` | 写文字 | `org`: 左下角坐标 | ==不支持中文== |
| `cv2.split(img)` | 拆分通道 | 返回(b,g,r) | 通道分离 |
| `cv2.merge([b,g,r])` | 合并通道 | 通道列表 | 通道合并 |
| `cv2.inRange(src, lower, upper)` | 颜色范围检测 | HSV范围 | 生成掩码 |
| `cv2.add(img1, img2, mask)` | 图像加法 | 可选掩码 | 饱和运算 |
| `cv2.addWeighted(img1, α, img2, β, γ)` | 图像混合 | `α+β=1` | 图像融合 |
| `cv2.bitwise_and(img1, img2, mask)` | 按位与 | `mask`: 蒙版 | 制作蒙版 |
| `cv2.copyMakeBorder(img, t,b,l,r, type)` | 边界填充 | `type`: 填充类型 | 图像扩边 |

**记忆要点：**
- OpenCV图像 = NumPy数组
- 图像shape = ==(高度, 宽度, 通道数)==
- 颜色格式 = ==BGR不是RGB==
- 像素范围 = 0-255（uint8）
- 坐标系统 = (x, y) 其中x是列，y是行

