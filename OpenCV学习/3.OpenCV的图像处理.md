# OpenCV的图像处理

## 图像的几何变换

几何变换用于改变图像的形状、大小、位置或角度，是图像处理中最基础也是最常用的操作。

---

### 1. 图像的缩放cv2.resize()

图像缩放就是改变图像的大小，可以放大或缩小。OpenCV提供了多种插值方法来保证缩放后的图像质量。

#### 1.1 基本缩放 - ==cv2.resize()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
print(f'原始大小：{img.shape}')

# 方法1：指定目标大小（宽, 高）
resized = cv2.resize(img, (400, 300))  # 注意：参数是(宽, 高)
print(f'缩放后大小：{resized.shape}')

# 方法2：按比例缩放
# 缩小为原来的50%
resized_half = cv2.resize(img, None, fx=0.5, fy=0.5)

# 放大为原来的2倍
resized_double = cv2.resize(img, None, fx=2, fy=2)

cv2.imshow('Original', img)
cv2.imshow('Resized', resized)
cv2.imshow('Half', resized_half)
cv2.imshow('Double', resized_double)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**函数参数：**
```python
cv2.resize(src, dsize, fx=0, fy=0, interpolation=cv2.INTER_LINEAR)
```

- ==`src`==：源图像
- ==`dsize`==：目标大小 `(width, height)`，==注意是(宽, 高)==
  - 如果指定了dsize，fx和fy会被忽略
  - 如果dsize为None，则必须指定fx和fy
- ==`fx`==：水平方向的缩放比例（宽度）
- ==`fy`==：垂直方向的缩放比例（高度）
- ==`interpolation`==：插值方法，决定缩放质量

**插值方法详解：**

| 插值方法 | 说明 | 速度 | 质量 | 适用场景 |
|---------|------|------|------|---------|
| `INTER_NEAREST` | 最近邻插值 | ==最快== | 最差 | 像素艺术、快速预览 |
| `INTER_LINEAR` | 双线性插值（==默认==） | 快 | 一般 | 大部分缩放场景 |
| `INTER_CUBIC` | 双三次插值 | 慢 | 好 | ==放大图像==（推荐） |
| `INTER_AREA` | 区域插值 | 中等 | 很好 | ==缩小图像==（推荐） |
| `INTER_LANCZOS4` | Lanczos插值 | ==最慢== | ==最好== | 高质量放大 |

**不同插值方法对比：**

```python
import cv2
img = cv2.imread('test.jpg')
# 先缩小再放大，观察不同插值方法的效果
small = cv2.resize(img, dsize = None, fx = 0.5, fy = 0.5)
# 用不同方法放大
nearest = cv2.resize(small, dsize = None, fx = 2, fy = 2, interpolation=cv2.INTER_NEAREST)
linear = cv2.resize(small, dsize = None, fx = 2, fy = 2, interpolation=cv2.INTER_LINEAR)
cubic = cv2.resize(small, dsize = None, fx = 2, fy = 2, interpolation=cv2.INTER_CUBIC)
lanczos = cv2.resize(small, dsize = None, fx = 2, fy = 2, interpolation=cv2.INTER_LANCZOS4)

# 显示对比
import matplotlib.pyplot as plt
fig, axes = plt.subplots(2, 2, figsize=(12, 12))
axes[0, 0].imshow(cv2.cvtColor(nearest, cv2.COLOR_BGR2RGB))
axes[0, 0].set_title('NEAREST (最快，质量最差)')
axes[0, 1].imshow(cv2.cvtColor(linear, cv2.COLOR_BGR2RGB))
axes[0, 1].set_title('LINEAR (默认)')
axes[1, 0].imshow(cv2.cvtColor(cubic, cv2.COLOR_BGR2RGB))
axes[1, 0].set_title('CUBIC (放大推荐)')
axes[1, 1].imshow(cv2.cvtColor(lanczos, cv2.COLOR_BGR2RGB))
axes[1, 1].set_title('LANCZOS4 (质量最好)')
for ax in axes.flat: ax.axis('off')
plt.tight_layout()
plt.show()
```
![[Pasted image 20251020170115.png]]


**很多时候我们需要保持图像的宽高比，避免图像变形。**
**就比如：我需要宽缩放到700，直接700/wight得到比例，然后高*这个比例就行**

**小结：**
- 缩放用 `cv2.resize()`
- ==放大用 `INTER_CUBIC`，缩小用 `INTER_AREA`==
- 参数dsize是 ==(宽, 高)== 不是 (高, 宽)
- 保持宽高比需要自己计算

---

### 2. 图像的平移==cv2.warpAffine()==

图像平移就是将图像在画布上移动位置，不改变大小和角度。平移需要构建一个仿射变换矩阵。

#### 2.1 基本平移 - ==cv2.warpAffine()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 构建平移矩阵
# 向右平移100像素，向下平移50像素
tx, ty = 100, 50
M = np.float32([[1, 0, tx],
                [0, 1, ty]])

# 应用平移变换
translated = cv2.warpAffine(img, M, (w, h))

cv2.imshow('Original', img)
cv2.imshow('Translated', translated)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**平移矩阵解释：**

```
M = [[1, 0, tx],
     [0, 1, ty]]
```

- `tx`：水平方向平移量（正数向右，负数向左）
- `ty`：垂直方向平移量（正数向下，负数向上）

**函数参数：**
```python
cv2.warpAffine(src, M, dsize, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=0)
```

- ==`src`==：源图像
- ==`M`==：2×3的变换矩阵（==仿射变换矩阵==）
- ==`dsize`==：输出图像的大小 `(width, height)`
- `flags`：插值方法（同resize）
- ==`borderMode`==：边界填充模式
  - `cv2.BORDER_CONSTANT`：常数填充（默认，填充黑色）
  - `cv2.BORDER_REPLICATE`：复制边缘
  - `cv2.BORDER_REFLECT`：镜像反射
- `borderValue`：边界填充值（当borderMode为CONSTANT时使用）

#### 2.2 四个方向的平移示例

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]
# 向右平移
M_right = np.float32([[1, 0, 100], [0, 1, 0]])
right = cv2.warpAffine(img, M_right, (w, h))
# 向左平移
M_left = np.float32([[1, 0, -100], [0, 1, 0]])
left = cv2.warpAffine(img, M_left, (w, h))
# 向下平移
M_down = np.float32([[1, 0, 0], [0, 1, 80]])
down = cv2.warpAffine(img, M_down, (w, h))
# 向上平移
M_up = np.float32([[1, 0, 0], [0, 1, -80]])
up = cv2.warpAffine(img, M_up, (w, h))
```

#### 2.3 自动居中平移

有时需要将图像移动到画布中心。

```python
import cv2
import numpy as np

def center_image(image, canvas_size):
    """
    将图像居中放置在指定大小的画布上
    """
    h, w = image.shape[:2]
    canvas_h, canvas_w = canvas_size
    
    # 计算偏移量（居中）
    tx = (canvas_w - w) // 2
    ty = (canvas_h - h) // 2
    
    # 平移矩阵
    M = np.float32([[1, 0, tx],
                    [0, 1, ty]])
    
    # 应用变换
    centered = cv2.warpAffine(image, M, (canvas_w, canvas_h))
    
    return centered

# 使用示例
img = cv2.imread('test.jpg')
print(f'原始大小：{img.shape[:2]}')

# 在800x600的画布上居中
centered = center_image(img, (800, 600))

cv2.imshow('Centered', centered)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**小结：**
- **平移用 `cv2.warpAffine()` + 平移矩阵**
- **平移矩阵：`[[1, 0, tx], [0, 1, ty]]`**
- **==tx正数向右，ty正数向下==**
- **超出边界的部分会被裁剪**

---

### 3. 图像的旋转==cv2.getRotationMatrix2D()==

图像旋转是围绕某个点（通常是中心点）旋转一定角度。OpenCV提供了便捷的函数来生成旋转矩阵。

#### 3.1 基本旋转 - ==cv2.getRotationMatrix2D()== + ==cv2.warpAffine()==

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 旋转中心（图像中心）
center = (w // 2, h // 2)

# 获取旋转矩阵
# 参数：旋转中心，旋转角度（逆时针），缩放比例
angle = 45  # 逆时针旋转45度
scale = 1.0  # 不缩放

M = cv2.getRotationMatrix2D(center, angle, scale)

# 应用旋转
rotated = cv2.warpAffine(img, M, (w, h))

cv2.imshow('Original', img)
cv2.imshow('Rotated 45°', rotated)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251020172734.png]]
**函数参数：**
```python
cv2.getRotationMatrix2D(center, angle, scale)
```

- ==`center`==：旋转中心点坐标 `(x, y)`
- ==`angle`==：旋转角度（==逆时针为正==，单位：度）
  - 45：逆时针旋转45度
  - -45：顺时针旋转45度
- ==`scale`==：缩放比例
  - 1.0：不缩放
  - 0.5：缩小到50%
  - 2.0：放大到200%
- **返回值**：2×3的仿射变换矩阵


```python
import cv2

img = cv2.imread('test.jpg')
h, w = img.shape[:2]
center = (w // 2, h // 2)
# 旋转90度（逆时针）
M_90 = cv2.getRotationMatrix2D(center, 90, 1.0)
rotated_90 = cv2.warpAffine(img, M_90, (w, h))
# 旋转180度
M_180 = cv2.getRotationMatrix2D(center, 180, 1.0)
rotated_180 = cv2.warpAffine(img, M_180, (w, h))
# 旋转270度（等于顺时针90度）
M_270 = cv2.getRotationMatrix2D(center, 270, 1.0)
rotated_270 = cv2.warpAffine(img, M_270, (w, h))
```
![[Pasted image 20251020172838.png]]

#### 3.2 围绕任意点旋转

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 在图像上标记旋转中心
img_marked = img.copy()
cv2.circle(img_marked, (w//4, h//4), 10, (0, 0, 255), -1)  # 红点标记

# 围绕左上角1/4处旋转
center_custom = (w // 4, h // 4)
M = cv2.getRotationMatrix2D(center_custom, 45, 1.0)
rotated_custom = cv2.warpAffine(img, M, (w, h))

# 围绕图像中心旋转（对比）
center_middle = (w // 2, h // 2)
M2 = cv2.getRotationMatrix2D(center_middle, 45, 1.0)
rotated_middle = cv2.warpAffine(img, M2, (w, h))

cv2.imshow('Marked Center', img_marked)
cv2.imshow('Rotate around (w/4, h/4)', rotated_custom)
cv2.imshow('Rotate around Center', rotated_middle)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

#### 3.3 旋转 + 缩放组合

```python
import cv2

img = cv2.imread('test.jpg')
h, w = img.shape[:2]
center = (w // 2, h // 2)

# 旋转45度并缩小到70%
M1 = cv2.getRotationMatrix2D(center, 45, 0.7)
rotated_shrink = cv2.warpAffine(img, M1, (w, h))

# 旋转-30度并放大到120%
M2 = cv2.getRotationMatrix2D(center, -30, 1.2)
rotated_enlarge = cv2.warpAffine(img, M2, (w, h))

cv2.imshow('Original', img)
cv2.imshow('Rotate 45° + Scale 70%', rotated_shrink)
cv2.imshow('Rotate -30° + Scale 120%', rotated_enlarge)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

> 💡 **插入图片位置**：旋转+缩放组合效果图

**小结：**
- ==**旋转用 `cv2.getRotationMatrix2D()` 生成矩阵**==
- ==**再用 `cv2.warpAffine()` 应用变换**==
- ==角度为正：逆时针旋转==
- ==角度为负：顺时针旋转==
- scale参数可以同时缩放
- 扩展画布需要重新计算边界

---

### 4. 仿射变换矩阵详解（重要！）⭐

在OpenCV中，平移、旋转、缩放、倾斜等操作都是通过 ==2×3的仿射变换矩阵== 来实现的。理解这个矩阵非常重要！

#### 4.1 矩阵结构

仿射变换矩阵的标准形式：

```
M = [[a,  b,  tx],
     [c,  d,  ty]]
```

对于图像中的任意一个点 `(x, y)`，经过变换后的新坐标 `(x', y')` 计算公式是：

```
x' = a*x + b*y + tx
y' = c*x + d*y + ty
```

#### 4.2 参数含义详解

| 参数 | 位置 | 作用 | 说明 |
|------|------|------|------|
| ==`a`== | M[0,0] | ==水平缩放== | `a>1`放大，`0<a<1`缩小，`a<0`水平翻转 |
| ==`b`== | M[0,1] | ==水平倾斜/旋转== | 控制x坐标受y影响的程度 |
| ==`tx`== | M[0,2] | ==水平平移== | 正数向右，负数向左 |
| ==`c`== | M[1,0] | ==垂直倾斜/旋转== | 控制y坐标受x影响的程度 |
| ==`d`== | M[1,1] | ==垂直缩放== | `d>1`放大，`0<d<1`缩小，`d<0`垂直翻转 |
| ==`ty`== | M[1,2] | ==垂直平移== | 正数向下，负数向上 |

#### 4.3 常见变换的矩阵形式

**1. 纯平移（向右100，向下50）**

```python
M = [[1, 0, 100],
     [0, 1, 50]]
```

- `a=1, d=1`：不缩放
- `b=0, c=0`：不旋转
- `tx=100, ty=50`：向右100，向下50

**2. 纯缩放（放大2倍）**

```python
M = [[2, 0, 0],
     [0, 2, 0]]
```

- `a=2, d=2`：水平和垂直都放大2倍
- `b=0, c=0`：不旋转
- `tx=0, ty=0`：不平移

**3. 水平翻转**

```python
# 假设图像宽度为w
M = [[-1, 0, w],
     [0, 1, 0]]
```

- `a=-1`：水平翻转（负数表示翻转）
- `d=1`：垂直不变
- `tx=w`：翻转后需要平移回可见区域

**4. 旋转45度（逆时针，围绕原点）**

```python
import numpy as np
angle = 45
theta = np.radians(angle)  # 转换为弧度

M = [[np.cos(theta), -np.sin(theta), 0],
     [np.sin(theta),  np.cos(theta), 0]]
```

对于45度：
```python
M ≈ [[0.707, -0.707, 0],
     [0.707,  0.707, 0]]
```

- `a=cos(θ), d=cos(θ)`：缩放分量
- `b=-sin(θ), c=sin(θ)`：旋转分量
- `tx=0, ty=0`：不平移

**5. 倾斜变换（错切）**

```python
# 水平倾斜
M = [[1, 0.5, 0],
     [0, 1,   0]]
```

效果：图像会向右倾斜，像平行四边形

#### 4.4 实际演示：手动构建变换矩阵

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 1. 只平移（向右100，向下50）
M1 = np.float32([[1, 0, 100],
                 [0, 1, 50]])
result1 = cv2.warpAffine(img, M1, (w, h))

# 2. 只缩放（放大1.5倍）
M2 = np.float32([[1.5, 0, 0],
                 [0, 1.5, 0]])
result2 = cv2.warpAffine(img, M2, (w, h))

# 3. 水平翻转
M3 = np.float32([[-1, 0, w],
                 [0, 1, 0]])
result3 = cv2.warpAffine(img, M3, (w, h))

# 4. 水平倾斜（错切）
M4 = np.float32([[1, 0.3, 0],
                 [0, 1, 0]])
result4 = cv2.warpAffine(img, M4, (w, h))

# 5. 组合变换：缩放+旋转+平移
angle = 30
theta = np.radians(angle)
scale = 0.8
tx, ty = 50, 30

M5 = np.float32([[scale*np.cos(theta), -scale*np.sin(theta), tx],
                 [scale*np.sin(theta),  scale*np.cos(theta), ty]])
result5 = cv2.warpAffine(img, M5, (w, h))

# 显示结果
import matplotlib.pyplot as plt
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
titles = ['原图', '平移(100,50)', '放大1.5倍', 
          '水平翻转', '水平倾斜', '组合变换']
images = [img, result1, result2, result3, result4, result5]

for ax, title, image in zip(axes.flat, titles, images):
    ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    ax.set_title(title)
    ax.axis('off')
    
plt.tight_layout()
plt.show()
```

![[Pasted image 20251023105216.png]]

#### 4.5 快速记忆口诀

```
[[缩放x, 倾斜x, 平移x],
 [倾斜y, 缩放y, 平移y]]
```

- **对角线 (a, d)**：控制缩放
- **副对角 (b, c)**：控制旋转/倾斜
- **最右列 (tx, ty)**：控制平移

---

### ==5. 透视变换（Perspective Transform）==

**透视变换比仿射变换更强大，可以实现==任意四边形到矩形==的变换（或反过来）。常用于：**
- 矫正倾斜拍摄的文档
- 矫正路牌、广告牌的视角
- 鸟瞰图变换
- 图像拼接

#### 仿射变换 vs 透视变换详细对比 ⭐

**核心区别一句话：**
- ==仿射变换==：平行线变换后==还是平行==（矩形→平行四边形）
- ==透视变换==：平行线变换后==可以相交==（矩形→梯形，有"近大远小"效果）

**详细对比表：**

| 对比项      | 仿射变换                       | 透视变换                            |
| -------- | -------------------------- | ------------------------------- |
| **矩阵大小** | 2×3矩阵                      | 3×3矩阵                           |
| **自由度**  | 6个参数                       | 8个参数                            |
| **需要点数** | ==3对点==                    | ==4对点==                         |
| **数学性质** | 线性变换（无除法）                  | 非线性变换（有除法）                      |
| **平行线**  | ✅ ==保持平行==                 | ❌ ==可以相交==（消失点）                 |
| **直线**   | ✅ 仍是直线                     | ✅ 仍是直线                          |
| **距离比例** | ✅ 保持                       | ❌ 不保持                           |
| **能力**   | 平移、旋转、缩放、倾斜                | 仿射的所有 + 透视投影                    |
| **生成矩阵** | `cv2.getAffineTransform()` | `cv2.getPerspectiveTransform()` |
| **应用变换** | `cv2.warpAffine()`         | `cv2.warpPerspective()`         |

**数学公式对比：**

仿射变换（线性，没有除法）：
```
x' = a*x + b*y + tx
y' = c*x + d*y + ty
```

透视变换（非线性，分母包含x和y）：
```
x' = (m11*x + m12*y + m13) / (m31*x + m32*y + m33)
y' = (m21*x + m22*y + m23) / (m31*x + m32*y + m33)
```

==透视变换的关键：分母会变化，导致不同位置的点缩放比例不同，产生"近大远小"效果！==

**什么时候用哪个？**

用**仿射变换**：
- ✅ 图像拍摄角度比较正
- ✅ 只需要旋转、缩放、平移、轻微倾斜
- ✅ 不涉及透视畸变

用**透视变换**：
- ✅ 图像拍摄角度很斜（==斜着拍的文档==）
- ✅ 需要矫正"近大远小"效果
- ✅ 需要做==鸟瞰图==转换（车道线检测）
- ✅ 四边形变换成任意四边形

**记忆口诀：**
```
仿射变换 - "平行守恒，3点定形"
- 平行线 → 还是平行线
- 3对点就够了
- 矩形变平行四边形

透视变换 - "近大远小，4点定形"  
- 平行线 → 可以相交
- 4对点才能定
- 矩形变任意四边形（包括梯形）
```

#### 5.1 基本透视变换 - ==cv2.getPerspectiveTransform()== + ==cv2.warpPerspective()==

```python
import cv2
import numpy as np
img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 定义源图像中的四个点（按顺序：左上、右上、左下、右下）
src_points = np.float32([
    [0, 0],      # 左上
    [w, 0],    # 右上
    [0, h],     # 左下
    [w, h]      # 右下
])

# 定义目标图像中对应的四个点
dst_points = np.float32([
    [0, 0],        # 左上
    [w, 30],        # 右上
    [50, h],        # 左下
    [w, h]         # 右下
])

# 计算透视变换矩阵（3×3矩阵）
M = cv2.getPerspectiveTransform(src_points, dst_points)

# 应用透视变换
result = cv2.warpPerspective(img, M, (w, h))

cv2.imshow('Original', img)
cv2.imshow('Perspective Transform', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![[Pasted image 20251023113420.png]]
**函数参数：**
```python
cv2.getPerspectiveTransform(src, dst)
```
- ==`src`==：源图像中的四个点（4×2的NumPy数组）
- ==`dst`==：目标图像中对应的四个点（4×2的NumPy数组）
- **返回值**：3×3的透视变换矩阵

```python
cv2.warpPerspective(src, M, dsize, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=0)
```
- ==`src`==：源图像
- ==`M`==：3×3的透视变换矩阵
- ==`dsize`==：输出图像大小 `(width, height)`
- `flags`：插值方法
- `borderMode`：边界填充模式
- `borderValue`：边界填充值

#### 5.2 实际应用：文档矫正

扫描倾斜文档后，将其矫正为正面视角。

```python
import cv2
import numpy as np

# 读取倾斜的文档图像
img = cv2.imread('document.jpg')
h, w = img.shape[:2]

# 手动指定文档的四个角点（实际应用中可以用角点检测自动获取）
# 顺序：左上、右上、右下、左下
src_points = np.float32([
    [145, 85],    # 左上
    [485, 70],    # 右上
    [510, 450],   # 右下
    [110, 465]    # 左下
])

# 计算矫正后的尺寸
# 计算宽度：取上边和下边的最大值
width_top = np.linalg.norm(src_points[1] - src_points[0])
width_bottom = np.linalg.norm(src_points[2] - src_points[3])
max_width = int(max(width_top, width_bottom))

# 计算高度：取左边和右边的最大值
height_left = np.linalg.norm(src_points[3] - src_points[0])
height_right = np.linalg.norm(src_points[2] - src_points[1])
max_height = int(max(height_left, height_right))

# 目标点（矩形四个角）
dst_points = np.float32([
    [0, 0],                    # 左上
    [max_width-1, 0],          # 右上
    [max_width-1, max_height-1],  # 右下
    [0, max_height-1]          # 左下
])

# 计算透视变换矩阵
M = cv2.getPerspectiveTransform(src_points, dst_points)

# 应用透视变换
warped = cv2.warpPerspective(img, M, (max_width, max_height))

# 在原图上标记四个角点
img_marked = img.copy()
for i, point in enumerate(src_points):
    cv2.circle(img_marked, tuple(point.astype(int)), 10, (0, 0, 255), -1)
    cv2.putText(img_marked, str(i+1), tuple(point.astype(int)), 
                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)

cv2.imshow('Original (Marked)', img_marked)
cv2.imshow('Corrected Document', warped)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

> 💡 **插入图片位置**：文档矫正效果图

#### 5.3 鸟瞰图变换（Bird's Eye View）

将倾斜视角的图像转换为俯视图，常用于车道线检测、停车位识别等。

```python
import cv2
import numpy as np

# 读取道路图像
img = cv2.imread('road.jpg')
h, w = img.shape[:2]

# 定义感兴趣区域的四个点（梯形区域）
src_points = np.float32([
    [w*0.25, h*0.6],   # 左上
    [w*0.75, h*0.6],   # 右上
    [w*0.95, h],       # 右下
    [w*0.05, h]        # 左下
])

# 目标鸟瞰图的四个点（矩形）
dst_points = np.float32([
    [w*0.2, 0],        # 左上
    [w*0.8, 0],        # 右上
    [w*0.8, h],        # 右下
    [w*0.2, h]         # 左下
])

# 计算透视变换矩阵
M = cv2.getPerspectiveTransform(src_points, dst_points)

# 应用透视变换
bird_view = cv2.warpPerspective(img, M, (w, h))

# 绘制原图的感兴趣区域
img_with_roi = img.copy()
pts = src_points.astype(np.int32).reshape((-1, 1, 2))
cv2.polylines(img_with_roi, [pts], True, (0, 255, 0), 3)

cv2.imshow('Original with ROI', img_with_roi)
cv2.imshow('Bird Eye View', bird_view)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

> 💡 **插入图片位置**：鸟瞰图变换效果图

#### 5.4 逆透视变换

有时需要将矫正后的图像还原回原始视角。

```python
import cv2
import numpy as np

img = cv2.imread('document.jpg')
h, w = img.shape[:2]

# 定义变换
src_points = np.float32([[50, 50], [w-50, 50], [w-50, h-50], [50, h-50]])
dst_points = np.float32([[0, 0], [w, 0], [w, h], [0, h]])

# 正向变换
M_forward = cv2.getPerspectiveTransform(src_points, dst_points)
warped = cv2.warpPerspective(img, M_forward, (w, h))

# 逆变换（从dst到src）
M_inverse = cv2.getPerspectiveTransform(dst_points, src_points)
restored = cv2.warpPerspective(warped, M_inverse, (w, h))

# 也可以直接求逆矩阵
# M_inverse = np.linalg.inv(M_forward)  # 注意：这个方法需要3x3矩阵

cv2.imshow('Original', img)
cv2.imshow('Warped', warped)
cv2.imshow('Restored', restored)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

#### 5.5 透视变换矩阵详解

透视变换矩阵是3×3的矩阵：

```
M = [[m11, m12, m13],
     [m21, m22, m23],
     [m31, m32, m33]]
```

变换公式（使用齐次坐标）：

```
x' = (m11*x + m12*y + m13) / (m31*x + m32*y + m33)
y' = (m21*x + m22*y + m23) / (m31*x + m32*y + m33)
```

**关键区别：**
- 仿射变换：只涉及线性变换（无除法）
- ==透视变换：分母包含x和y，产生非线性效果==（远处的物体看起来更小）

#### 5.6 透视变换 vs 仿射变换对比

```python
import cv2
import numpy as np

img = cv2.imread('test.jpg')
h, w = img.shape[:2]

# 定义四个点
src_affine = np.float32([[0, 0], [w, 0], [0, h]])
dst_affine = np.float32([[50, 50], [w-50, 50], [50, h-50]])

src_perspective = np.float32([[0, 0], [w, 0], [w, h], [0, h]])
dst_perspective = np.float32([[50, 50], [w-50, 50], [w-100, h-50], [100, h-50]])

# 仿射变换（需要3个点）
M_affine = cv2.getAffineTransform(src_affine, dst_affine)
affine_result = cv2.warpAffine(img, M_affine, (w, h))

# 透视变换（需要4个点）
M_perspective = cv2.getPerspectiveTransform(src_perspective, dst_perspective)
perspective_result = cv2.warpPerspective(img, M_perspective, (w, h))

# 显示对比
import matplotlib.pyplot as plt
fig, axes = plt.subplots(1, 3, figsize=(15, 5))
axes[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[0].set_title('原图')
axes[1].imshow(cv2.cvtColor(affine_result, cv2.COLOR_BGR2RGB))
axes[1].set_title('仿射变换（平行线保持平行）')
axes[2].imshow(cv2.cvtColor(perspective_result, cv2.COLOR_BGR2RGB))
axes[2].set_title('透视变换（平行线可以相交）')
for ax in axes: ax.axis('off')
plt.tight_layout()
plt.show()
```

> 💡 **插入图片位置**：仿射 vs 透视变换对比图

**小结：**
- **透视变换用 `cv2.getPerspectiveTransform()` 生成矩阵**
- **再用 `cv2.warpPerspective()` 应用变换**
- ==需要4对点==（仿射变换只需3对点）
- ==3×3矩阵==，8个自由度
- 可以矫正倾斜、实现鸟瞰图
- 常用场景：文档扫描、车道检测、AR应用

---

### 快速参考

#### 缩放
```python
# 指定大小
cv2.resize(img, (width, height), interpolation=cv2.INTER_AREA)

# 按比例
cv2.resize(img, None, fx=0.5, fy=0.5)
```

#### 平移
```python
M = np.float32([[1, 0, tx], [0, 1, ty]])
cv2.warpAffine(img, M, (width, height))
```

#### 旋转
```python
M = cv2.getRotationMatrix2D((cx, cy), angle, scale)
cv2.warpAffine(img, M, (width, height))
```

#### 透视变换
```python
# 定义4对点
src = np.float32([[x1,y1], [x2,y2], [x3,y3], [x4,y4]])
dst = np.float32([[x1,y1], [x2,y2], [x3,y3], [x4,y4]])

M = cv2.getPerspectiveTransform(src, dst)
result = cv2.warpPerspective(img, M, (width, height))
```

---

### 小结

**图像缩放：**
- ==放大用 `INTER_CUBIC`==
- ==缩小用 `INTER_AREA`==
- dsize参数是(宽, 高)

**图像平移：**
- 平移矩阵：`[[1, 0, tx], [0, 1, ty]]`
- tx正数向右，负数向左
- ty正数向下，负数向上

**图像旋转：**
- ==角度为正：逆时针==
- ==角度为负：顺时针==
- 可同时缩放（scale参数）
- 默认会裁剪，需要完整图像要扩展画布

**仿射变换矩阵：**
- 2×3矩阵，6个参数
- 对角线控制缩放，副对角控制旋转，最右列控制平移
- ==保持平行线平行==

**透视变换：**
- 3×3矩阵，8个参数
- 需要4对点（仿射只需3对点）
- ==平行线可以不平行==
- 常用于文档矫正、鸟瞰图

**常用函数：**
- `cv2.resize()` - 缩放
- `cv2.warpAffine()` - 应用仿射变换（平移、旋转）
- `cv2.getRotationMatrix2D()` - 生成旋转矩阵
- `cv2.getPerspectiveTransform()` - 生成透视变换矩阵
- `cv2.warpPerspective()` - 应用透视变换

